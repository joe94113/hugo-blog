[{"categories":["Laravel"],"contents":"Laravel Seeders 簡介 Laravel 可以使用 seed 類別，填充測試用的資料，或者是說這個資料表的資料都是固定的不會更動，也可以使用 seed 來創建資料\n撰寫 seeder 首先透過 artisan 指令來生成 seeder 檔案，命名規則也應遵守大小寫，類似UserTableSeeder 。\nphp artisan make:seeder UserTableSeeder\n創建完成後開啟，會看到只有一個預設的方法:run。當執行db:seed就會跑 run 底下的程式碼，在 run 方法中可以新增你想新增進資料庫的數據，可以使用 DB 或是 Eloquent ORM 對資料進行新增。\nlaravel 有預先有一個DatabaseSeeder 的檔案，在database\\seeds底下，可以在 run 裡面新增程式碼。\n\u0026lt;?php\ruse Illuminate\\Database\\Seeder;\ruse Illuminate\\Database\\Eloquent\\Model;\rclass DatabaseSeeder extends Seeder\r{\r/**\r* Run the database seeds.\r*\r* @return void\r*/\rpublic function run()\r{\rDB::table(\u0026#39;users\u0026#39;)-\u0026gt;insert([\r\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;joe\u0026#39;,\r\u0026#39;email\u0026#39; =\u0026gt; \u0026#39;joe@gmail.com\u0026#39;,\r\u0026#39;password\u0026#39; =\u0026gt; bcrypt(\u0026#39;secret\u0026#39;),\r]);\r}\r}\r使用 factory 創建假資料 手動為 seed 要一一指定屬性是很麻煩的，可以使用 factory 這個輔助方法函式來新增數據到資料庫中，當一開始資料庫沒有資料，要測試的時候可以這麼做。\n舉例創建 50 個 user 並與 post 關聯。\npublic function run()\r{\rfactory(App\\User::class, 50)-\u0026gt;create()-\u0026gt;each(function($u) {\r$u-\u0026gt;posts()-\u0026gt;save(factory(App\\Post::class)-\u0026gt;make());\r});\r}\r呼叫其他 Seeders 在DatabaseSeeder類別，可以使用 call 方法執行其他的 seed 類別。 這樣可以避免單一個 seeders 過於龐大。\n只需要傳遞你想要 run 的 seeder 類別名稱就好\n/**\r* Run the database seeds.\r*\r* @return void\r*/\rpublic function run()\r{\rModel::unguard();\r$this-\u0026gt;call(UsersTableSeeder::class);\r$this-\u0026gt;call(PostsTableSeeder::class);\r$this-\u0026gt;call(CommentsTableSeeder::class);\rModel::reguard();\r}\r執行 seeders 一旦撰寫完成 seeder 類別，可以使用db:seed的 artisan 指令對資料庫進行填充，db:seed將會運行DatabaseSeeder類別，透過他來呼叫其他 seeders，但也可以使用\u0026ndash;class 來單獨運行指定的 seeder 類別:\nphp artisan db:seed\rphp artisan db:seed --class=UserTableSeeder\r你也可以使用 migrate:refresh 指令來對資料庫進行資料填充，它會推回所有 migration(遷移檔案)並再次執行所有遷移並執行所有 seeder。在完全重建你的資料庫時這個指令是非常有用的：\nphp artisan migrate:refresh --seed\n","permalink":"https://joe94113.github.io/blog/laravel_seeder/","tags":["Backend"],"title":"Laravel Seeders"},{"categories":["MySQL"],"contents":"DATE、TIME、DATETIME 和 TIMESTAMP 類型之間有什麼區別 DATE： 具有日期部分但沒有時間部分的值。 MySQL 以YYYY-MM-DD格式檢索和顯示 DATE 值。支持的範圍是 1000-01-01 到 9999-12-31。\nDATETIME： 用於包含日期和時間部分的值。 MySQL 以YYYY-MM-DD HH:MM:SS格式顯示 DATETIME 值。 支持的範圍是 1000-01-01 00:00:00 到 9999-12-31 23:59:59。\nTIMESTAMP： 包含日期和時間部分的值，並包括時區。 TIMESTAMP 的範圍是 1970-01-01 00:00:01UTC 到 2038-01-19 03:14:07UTC。\nTIME： 其值採用HH:MM:SS格式（或 HHH:MM:SS 格式用於大小時值）。 TIME 值範圍從-838:59:59 到 838:59:59。小時部分可能如此之大，因為 TIME 類型不僅可以用於表示一天中的某個時間（必須小於 24 小時），還可以表示經過的時間或兩個事件之間的時間間隔（可能遠大於 24 小時，甚至是負的）。\n","permalink":"https://joe94113.github.io/blog/sql_time_type_difference/","tags":["SQL"],"title":"DATE、TIME、DATETIME 和 TIMESTAMP 類型之間有什麼區別"},{"categories":["Laravel","AJAX"],"contents":"Laravel csrf token mismatch for ajax POST Request 在 laravel 裡使用 ajax post 方法遇到 CSRF Token 不符問題\nIn header\n\u0026lt;meta name=\u0026quot;csrf-token\u0026quot; content=\u0026quot;{{ csrf_token() }}\u0026quot; /\u0026gt;\nIn script\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt;\r$.ajaxSetup({\rheaders: {\r\u0026#39;X-CSRF-TOKEN\u0026#39;: $(\u0026#39;meta[name=\u0026#34;csrf-token\u0026#34;]\u0026#39;).attr(\u0026#39;content\u0026#39;)\r}\r});\r\u0026lt;/script\u0026gt;\r ","permalink":"https://joe94113.github.io/blog/laravel%E4%BD%BF%E7%94%A8ajax_post%E5%95%8F%E9%A1%8C/","tags":["Backend"],"title":"Laravel csrf token mismatch for ajax POST Request"},{"categories":["PHP"],"contents":"解決 json_encode 格式化的數據出現反斜杠的問題 在上傳多個圖片檔案使用 json_encode 格式化完成時發現\n原先陣列資料：[\u0026quot;/img/store/1635141776.png\u0026quot;,\u0026quot;/img/store/1635141776.png\u0026quot;,\u0026quot;/img/store/1635141776.png\u0026quot;]\n陣列路徑被轉換以下 [\u0026quot;\\/img\\/store\\/1635141776.png\u0026quot;,\u0026quot;\\/img\\/store\\/1635141776.png\u0026quot;,\u0026quot;\\/img\\/store\\/1635141776.png\u0026quot;] 只要有\u0026rdquo; / \u0026ldquo;就會變成\u0026rdquo; \\/ \u0026ldquo;，這樣無法讀取到檔案\n可以使用以下兩種解決辦法 $data = [\u0026quot;/img/store/1635141776.png\u0026quot;,\u0026quot;/img/store/1635141776.png\u0026quot;,\u0026quot;/img/store/1635141776.png\u0026quot;]\n  使用 PHP 自帶的參數：JSON_UNESCAPED_SLASHES json_encode($data, JSON_UNESCAPED_SLASHES);\n  字串替換 str_replace(\u0026quot;\\\\\u0026quot;, \u0026quot;/\u0026quot;, json_encode($data))\n  ","permalink":"https://joe94113.github.io/blog/%E8%A7%A3%E6%B1%BA-json_encode%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%95%8F%E9%A1%8C/","tags":["Backend"],"title":"解決 json_encode 格式化的數據出現反斜杠的問題"},{"categories":["Laravel"],"contents":"Laravel use notification when some data add 今天就舉一個例子，如果有商家新增了，將通知給使用者 1. 下載 laravel notofocation 資料表 php artisan notifications:table\rphp artisan migrate\r2. 創建 notification php artisan make:notification StoreAdded\r3. 撰寫 StoreAdded.php 回傳程式碼 toarray 函式，就是我們要發送的資料，會是一個 json。 因為是使用 database，所以要將 via 裡改成 database\n\u0026lt;?php\rnamespace App\\Notifications;\ruse Carbon\\Carbon;\ruse Illuminate\\Bus\\Queueable;\ruse Illuminate\\Contracts\\Queue\\ShouldQueue;\ruse Illuminate\\Notifications\\Messages\\MailMessage;\ruse Illuminate\\Notifications\\Notification;\rclass StoreAdded extends Notification\r{\ruse Queueable;\r/**\r* Create a new notification instance.\r*\r* @return void\r*/\rpublic function __construct($store)\r{\r$this-\u0026gt;store = $store;\r}\r/**\r* Get the notification\u0026#39;s delivery channels.\r*\r* @param mixed $notifiable\r* @return array\r*/\rpublic function via($notifiable)\r{\rreturn [\u0026#39;database\u0026#39;];\r}\r/**\r* Get the mail representation of the notification.\r*\r* @param mixed $notifiable\r* @return \\Illuminate\\Notifications\\Messages\\MailMessage\r*/\rpublic function toMail($notifiable)\r{\rreturn (new MailMessage)\r-\u0026gt;line(\u0026#39;The introduction to the notification.\u0026#39;)\r-\u0026gt;action(\u0026#39;Notification Action\u0026#39;, url(\u0026#39;/\u0026#39;))\r-\u0026gt;line(\u0026#39;Thank you for using our application!\u0026#39;);\r}\r/**\r* Get the array representation of the notification.\r*\r* @param mixed $notifiable\r* @return array\r*/\rpublic function toArray($notifiable)\r{\rreturn [\r\u0026#39;message\u0026#39; =\u0026gt; $this-\u0026gt;store-\u0026gt;name . \u0026#39;加入囉！\u0026#39;,\r\u0026#39;date\u0026#39; =\u0026gt; Carbon::now()-\u0026gt;format(\u0026#39;m-d H:i\u0026#39;),\r];\r}\r}\r4. 在 User 模型加入 Notifiable \u0026lt;?php\rnamespace App;\ruse App\\Notifications\\StoreAdded;\ruse Illuminate\\Notifications\\Notifiable;\rclass User extends Authenticatable implements MustVerifyEmail\r{\ruse Notifiable;\r/**\r* The attributes that are mass assignable.\r*\r* @var array\r*/\rprotected $fillable = [\r\u0026#39;name\u0026#39;,\r\u0026#39;email\u0026#39;,\r\u0026#39;password\u0026#39;,\r];\rpublic function sendStoreAddedNotification($store)\r{\r$this-\u0026gt;notify(new StoreAdded($store));\r}\r}\r5. 新增商家發送通知 將發送通知程式碼接在 save 後面，當新增成功才將通知加到資料庫，user 可以設定要傳給哪些人\n// 找到所有使用者發送\r$users = User::all();\rforeach ($users as $user) {\r$user-\u0026gt;sendStoreAddedNotification($store);\r}\r6. 讀取通知 以下為讀取所有通知\n$user=App\\Models\\User::find(1);\rforeach ($user-\u0026gt;notifications as $notification) {\recho $notification-\u0026gt;type;\r}\r以下為讀取未讀取通知\n$user=App\\Models\\User::find(1);\rforeach ($user-\u0026gt;unreadNotifications as $notification) {\recho $notification-\u0026gt;type;\r}\r7. 將通知變成已讀取 可以一條一條設為已讀取\n$user=App\\Models\\User::find(1);\rforeach ($user-\u0026gt;unreadNotifications as $notification) {\r$notification-\u0026gt;markAsRead();\r}\r也可以一次把撈出來的 user 通知設為已讀取 $user-\u0026gt;unreadNotifications-\u0026gt;markAsRead();\n取出單筆通知(不一定是個好方法)\n$user = App\\Models\\User::find(1);\r$notification = $user-\u0026gt;notifications()-\u0026gt;find($notificationid);\rif($notification) {\r$notification-\u0026gt;markAsRead();\r}\r刪除通知 $user-\u0026gt;notifications()-\u0026gt;delete();\n補充 內建 notification 模型放在這裡，可以使用普通數據庫查詢 Illuminate\\Notifications\\DatabaseNotification\n","permalink":"https://joe94113.github.io/blog/laravel_storeadd_notification_to_user/","tags":["Backend"],"title":"Laravel use notification when some data add"},{"categories":["Javascript"],"contents":"JS 取得目前瀏覽器位置 Navigator.geolocation DOC\nNavigator.geolocation 回傳一個唯讀的 Geolocation 物件，透過這個物件可以存取設備的位置訊息。同時也允許網站或應用程式根據使用者的位置提供客製化的結果。\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;button onclick=\u0026#34;getLocation()\u0026#34;\u0026gt;取得您目前所在位置的經緯度\u0026lt;/button\u0026gt;\r\u0026lt;p id=\u0026#34;msg\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;script\u0026gt;\rvar m = document.getElementById(\u0026#34;msg\u0026#34;);\rfunction getLocation() {\r//取得 經緯度\r if (navigator.geolocation) {\r//\r navigator.geolocation.getCurrentPosition(showPosition); //有拿到位置就呼叫 showPosition 函式\r } else {\rm.innerHTML =\r\u0026#34;您的瀏覽器不支援 顯示地理位置 API ，請使用其它瀏覽器開啟 這個網址\u0026#34;;\r}\r}\rfunction showPosition(position) {\rm.innerHTML =\r\u0026#34; 緯度 (Latitude): \u0026#34; +\rposition.coords.latitude +\r\u0026#34;\u0026lt;br\u0026gt;經度 (Longitude): \u0026#34; +\rposition.coords.longitude;\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r接下來實測看看\n成功拉!!!\n","permalink":"https://joe94113.github.io/blog/js_get_location/","tags":["Frontend"],"title":"JS取得目前瀏覽器位置"},{"categories":["Laravel"],"contents":"Laravel Carbon format now time use Carbon\\Carbon;\r$date = Carbon::now();\r$formatedDate = $date-\u0026gt;format(\u0026#39;Y-m-d H:i:s\u0026#39;);\recho($formatedDate);\r","permalink":"https://joe94113.github.io/blog/laravel_carbon_format_nowtime/","tags":["Backend"],"title":"Laravel Carbon format now time"},{"categories":["Laravel","JQuery"],"contents":"How to use Chosen JQuery plugin on Laravel chosen packagist\n1. Install `composer require harvesthq/chosen`\r 2. Import Import jquery first, otherwise an error will occur\n\u0026lt;script src=\u0026#34;https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026#34;https://cdn.rawgit.com/harvesthq/chosen/gh-pages/chosen.jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;link\rhref=\u0026#34;https://cdn.rawgit.com/harvesthq/chosen/gh-pages/chosen.min.css\u0026#34;\rrel=\u0026#34;stylesheet\u0026#34;\r/\u0026gt;\r3. add form \u0026lt;script src=\u0026#34;https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026#34;https://cdn.rawgit.com/harvesthq/chosen/gh-pages/chosen.jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;link\rhref=\u0026#34;https://cdn.rawgit.com/harvesthq/chosen/gh-pages/chosen.min.css\u0026#34;\rrel=\u0026#34;stylesheet\u0026#34;\r/\u0026gt;\r\u0026lt;script\u0026gt;\r$(document).ready(function () {\r$(\u0026#34;.chosen-select\u0026#34;).chosen({\rno_results_text: \u0026#34;Oops, nothing found!\u0026#34;,\r});\r});\r\u0026lt;/script\u0026gt;\r\u0026lt;form action=\u0026#34;http://httpbin.org/post\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt;\r\u0026lt;select\rdata-placeholder=\u0026#34;select your favorite fruit\u0026#34;\rmultiple\rclass=\u0026#34;chosen-select\u0026#34;\rname=\u0026#34;fruit[]\u0026#34;\r\u0026gt;\r\u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/option\u0026gt;\r\u0026lt;option\u0026gt;Apple\u0026lt;/option\u0026gt;\r\u0026lt;option\u0026gt;Banana\u0026lt;/option\u0026gt;\r\u0026lt;option\u0026gt;Cherry\u0026lt;/option\u0026gt;\r\u0026lt;option\u0026gt;Kiwi fruit\u0026lt;/option\u0026gt;\r\u0026lt;option\u0026gt;Mango\u0026lt;/option\u0026gt;\r\u0026lt;option\u0026gt;Orange\u0026lt;/option\u0026gt;\r\u0026lt;option\u0026gt;Papaya\u0026lt;/option\u0026gt;\r\u0026lt;option\u0026gt;Sapota\u0026lt;/option\u0026gt;\r\u0026lt;/select\u0026gt;\r\u0026lt;input type=\u0026#34;submit\u0026#34; /\u0026gt;\r\u0026lt;/form\u0026gt;\rRun code  Submit  Need more changes see chosen doc\n","permalink":"https://joe94113.github.io/blog/laravel_use_chosen/","tags":["Backend"],"title":"How to use Chosen JQuery plugin on Laravel"},{"categories":["Laravel"],"contents":"Laravel how to post values from a multiple select 首先，記得在你的 select tag 的 name 後面加上括號[]，這樣子在複選後，傳到後端去的時候才會取得到複選的所有值。\n使用 dd() 函式印出，就可以看到陣列裡面包含選住的值\nFirst , remember to add parentheses [] after the name of your select tag, so that after the select, all the checked values will be obtained when it is passed to the backend.\nUse the dd() function to print out, you can see that the array contains the selected value.\n\u0026lt;form id=\u0026#34;form\u0026#34; action=\u0026#34;\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;select id=\u0026#34;number\u0026#34; name=\u0026#34;number[]\u0026#34; multiple=\u0026#34;multiple\u0026#34;\u0026gt;\r\u0026lt;option value=\u0026#34;1\u0026#34;\u0026gt;1\u0026lt;/option\u0026gt;\r\u0026lt;option value=\u0026#34;2\u0026#34;\u0026gt;2\u0026lt;/option\u0026gt;\r\u0026lt;option value=\u0026#34;3\u0026#34;\u0026gt;3\u0026lt;/option\u0026gt;\r\u0026lt;option value=\u0026#34;4\u0026#34;\u0026gt;4\u0026lt;/option\u0026gt;\r\u0026lt;/select\u0026gt;\r\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;submit\u0026#34; /\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/form\u0026gt;\r","permalink":"https://joe94113.github.io/blog/laravel_post_multipleselect_values/","tags":["Backend"],"title":"Laravel how to post values from a multiple select"},{"categories":["PHP"],"contents":"PHP 學習筆記(持續更新中) PHP 的資料型態 Bollean 布林值 算是最簡單的資料型態，可以為 true 跟 false 不區分大小寫。\n\u0026lt;?php $foo = true; // 設置foo變數為true ?\u0026gt; 常用在判斷式\n\u0026lt;?php // 兩個等於代表操作符，檢測兩個遍量是否相等，返回布林值 if ($password == \u0026#39;123\u0026#39;){ echo \u0026#39;pass\u0026#39;; } // 這樣寫是不必要的 if ($check == true){ echo \u0026#39;check in\u0026#39;; } // 可以使用以下方式 if ($check){ echo \u0026#39;check in\u0026#39;; } ?\u0026gt;  Integer 整數型態 整型值 int 可以使用十进制，十六进制，八进制或二进制表示，前面可以加上可選的符號（- 或者 +）。 可以用負運算符 来表示一个負的 int。\n\u0026lt;?php $a = 10; // 十進位 $a = 012; // 八進位 (等於十進位 10) $a = 0xa; // 十六進位 (等于十進制 10) $a = 0b1010; // 二進制数字 (等于十進制 10) $a = 1_0_1_0_; // 整型数值 (PHP 7.4.0 以后)輸出1010 ?\u0026gt; 整數溢出，如果超過 int 範圍會轉換成 float 型態。\n\u0026lt;?php // var_dump()方法是判斷一個變量的類型與長度,並輸出變量的數值 $large_number = 2147483647; var_dump($large_number); // int(2147483647)  $large_number = 2147483648; var_dump($large_number); // float(2147483648) ?\u0026gt;  Float 符點數 擁有小數點的正負數值， 通常最大值是 1.8e308 並具有 14 位十進制數字的精度。\n\u0026lt;?php $num = 99.01; $num = -50.30; ?\u0026gt;  string 字符串 由字符組成，每個字符等同於一個字節。這意味著 PHP 只能支持 256 的字符集，因此不支持 Unicode 。\n 注意:在 32 位版本中，string 最大可以達到 2GB（最多 2147483647 字節）。\n 定義一個字符串最簡單就是用'\u0026lsquo;單引號刮起來。\n\u0026lt;?php $text = \u0026#39;This is test string\u0026#39;; echo $text; // 輸出: This is test string ?\u0026gt; 如果包含在雙引號內就可以對特殊字符進行解析。\n\u0026lt;?php // 可以直接將變數帶入 $food = \u0026#39;noodles\u0026#39;; echo \u0026#34;Hi \\n\u0026#34;; // 換行 echo \u0026#34;I like to eat $food\u0026#34;; ?\u0026gt;  Array 數組 PHP 中的 array 實際上是一個有序映射。映射是一種把 values 關聯到 keys 的類型。\n可以用 array() 方法來結構一個 array 。接受任意數量用逗號分隔的 鍵（key） =\u0026gt; 值（value） 。以下範例:\n\u0026lt;?php $arry = array( 0 =\u0026gt; \u0026#39;apple\u0026#39;, 1 =\u0026gt; \u0026#39;tomato\u0026#39;, 2 =\u0026gt; \u0026#39;banana\u0026#39;,); echo $arry[0]; // apple  // 可以使用以下短數組語法 $arry = [ 0 =\u0026gt; \u0026#39;apple\u0026#39;, 1 =\u0026gt; \u0026#39;tomato\u0026#39;, 2 =\u0026gt; \u0026#39;banana\u0026#39;,]; echo $arry[0]; // apple ?\u0026gt; 沒有鍵名的索引數組\n\u0026lt;?php $array = array(\u0026#34;apple\u0026#34;, \u0026#34;tomato\u0026#34;, \u0026#34;banana\u0026#34;, ); var_dump($array); // 輸出 array(4) { [0]=\u0026gt; string(5) \u0026#34;apple\u0026#34; [1]=\u0026gt; string(6) \u0026#34;tomato\u0026#34; [2]=\u0026gt; string(6) \u0026#34;banana\u0026#34; } ?\u0026gt; 數組可以用在許多地方，以下有些範例\n\u0026lt;?php $map = array( \u0026#39;version\u0026#39; =\u0026gt; 4, \u0026#39;OS\u0026#39; =\u0026gt; \u0026#39;Linux\u0026#39;, \u0026#39;lang\u0026#39; =\u0026gt; \u0026#39;english\u0026#39;, \u0026#39;short_tags\u0026#39; =\u0026gt; true ); // . . .完全等同於: $a = array(); $a[\u0026#39;version\u0026#39;] = 4; $a[\u0026#39;os\u0026#39;] = \u0026#39;Linux\u0026#39;; $a[\u0026#39;lang\u0026#39;] = \u0026#39;english\u0026#39;; $a[\u0026#39;short_tags\u0026#39;] = true; unset($a[\u0026#39;os\u0026#39;]); // 刪除 \u0026#34;Linux\u0026#34; ?\u0026gt; 輸出集合\n\u0026lt;?php $maps = array( \u0026#39;version\u0026#39; =\u0026gt; 4, \u0026#39;OS\u0026#39; =\u0026gt; \u0026#39;Linux\u0026#39;, \u0026#39;lang\u0026#39; =\u0026gt; \u0026#39;english\u0026#39;, \u0026#39;short_tags\u0026#39; =\u0026gt; true ); foreach ($maps as $key =\u0026gt; $value) { echo \u0026#34;$keyis $value\\n\u0026#34;; } // version is 4 // OS is Linux // lang is english // short_tags is 1 ?\u0026gt; Array 是有序的。也可以使用不同的排序函数来改變順序。\n數組排序範例\n\u0026lt;?php sort($files); // 對value排序 print_r($files); ?\u0026gt;  Iterable 可迭代對象 它接受任何 array 或實現了 Traversable(可遍歷) 接口的對象。 這些類型都能用 foreach 迭代， 也可以和 生成器 里的 yield from 一起使用。\n\u0026lt;?php function gen(): iterable { // 建立一個可迭代生成器  yield 1; yield 2; yield 3; } $iterable = gen(); // 實例化 foreach($iterable as $value){ echo \u0026#34;$value\\n\u0026#34;; } // 輸出 // 1 // 2 // 3  // 答案相同 function gen(): iterable { return [1, 2, 3]; } $iterable = gen(); foreach($iterable as $value){ echo \u0026#34;$value\\n\u0026#34;; } ?\u0026gt;  Object 對象 要創建一个新的對象 object，使用 new 語句實例化一个類：\n\u0026lt;?php class SayHi { function do_sayhi() { echo \u0026#34;Hello.\u0026#34;; } } $bar = new foo; $bar-\u0026gt;do_sayhi(); // Hello ?\u0026gt; 如果將 Object 轉換成 Object 將不會有任何變化，如果其它任何類型的值被轉換成對象，將會創建一个内置類 stdClass 的實例。如果该值为 null，則新的實例為空。 array 轉換成 object 將使 Key 值成為屬性名並具有相對應的值，參考以下範例\n\u0026lt;?php $obj = (object) array(\u0026#39;1\u0026#39; =\u0026gt; \u0026#39;foo\u0026#39;); var_dump(isset($obj-\u0026gt;{\u0026#39;1\u0026#39;})); // PHP 7.2.0 後輸出 \u0026#39;bool(true)\u0026#39;，之前版本會輸出 \u0026#39;bool(false)\u0026#39; var_dump(key($obj)); // PHP 7.2.0 後輸出 \u0026#39;string(1) \u0026#34;1\u0026#34;\u0026#39;，之前版本輸出 \u0026#39;int(1)\u0026#39; ?\u0026gt; 對於其他值，會包含進成員變量名 scalar。\n\u0026lt;?php $obj = (object) \u0026#39;hello\u0026#39;; echo $obj-\u0026gt;scalar; // outputs \u0026#39;hello\u0026#39; ?\u0026gt;  Null 類型 特殊的 null 值表示一个變數没有值。NULL 類型唯一可能的值就是 null。\n在下列情况下一个變數被认为是 null：\n  被賦值为 null。\n  尚未被賦值。\n  被 unset()。\n  null 類型只有一个值，就是不區分大小寫的常量 null。\n\u0026lt;?php $var = NULL; ?\u0026gt; PHP 變數命名規則 PHP 中的變數用一个美元符號後面跟變數名稱来表示。變數名是區分大小寫的。\n變數名與 PHP 中其它的標籤一样遵循相同的規則。一个有效的變量名由字母或者底線開頭，後面加上任意数量的字母，数字，或者底線。 按照正常的正規表示法，他將被表達為：'^[a-zA-Z_\\x80-\\xff][a-za-z0-9_\\x80-\\xff]*$\u0026rsquo;。\n $this 是一個特殊變數，他不能被賦值。\n \u0026lt;?php $firstName = \u0026#39;Wang\u0026#39;; $lastName = \u0026#39;Joe\u0026#39;; echo \u0026#34;$firstName, $lastName\u0026#34;; // 输出 \u0026#34;Wang, Joe\u0026#34;  $4site = \u0026#39;not yet\u0026#39;; // 非法變數名；以數字開頭 $_4site = \u0026#39;not yet\u0026#39;; // 合法變數名；以底線開頭 $i站點is = \u0026#39;TW\u0026#39;; // 合法變數名；可以用中文 ?\u0026gt; PHP 常量 可以使用 const 關鍵字或 define() 函數兩種方法來定義一個常量。函數 define() 允許將常量定義為一個表達式，而 const 關鍵字有一些限制。一個常量一旦被定義，就不能再改變或者取消定義。\n使用 const 關鍵字定義常量時，只能包含標量數據（bool、int、float 、string）。可以將常量定義為一個表達式，也可以定義為一個 array。還可以定義 resource 為常量，但應盡量避免，因為可能會造成不可預料的結果。\n可以簡單的通過指定其名字來取得常量的值，與變量不同，不應該在常量前面加上 $ 符號。如果常量名是動態的，也可以用函數 constant() 來獲取常量的值。用 get_defined_constants() 可以獲得所有已定義的常量列表。\n以下為定義常量範例\n\u0026lt;?php define(\u0026#34;CONSTANT\u0026#34;, \u0026#34;Hello world.\u0026#34;); echo CONSTANT; // 輸出 \u0026#34;Hello world.\u0026#34; echo Constant; // 拋出錯誤：未定義的常量 \u0026#34;Constant\u0026#34;  // 在 PHP 8.0.0 之前，输出 \u0026#34;Constant\u0026#34; 會併發出一個提示級別錯誤訊息 ?\u0026gt; 以下範例為使用關鍵字 const 定義常量\n\u0026lt;?php // 簡單的標量值 const CONSTANT = \u0026#39;Hello World\u0026#39;; echo CONSTANT; // 標量表達式 const ANOTHER_CONST = CONSTANT.\u0026#39;; Goodbye World\u0026#39;; echo ANOTHER_CONST; const ANIMALS = array(\u0026#39;dog\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;bird\u0026#39;); echo ANIMALS[1]; // 將輸出 \u0026#34;cat\u0026#34;  // 常量數組 define(\u0026#39;ANIMALS\u0026#39;, array( \u0026#39;dog\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;bird\u0026#39; )); echo ANIMALS[1]; // 將輸出 \u0026#34;cat\u0026#34; ?\u0026gt; 魔術常量\n   名字 說明     __LINE__ 文件中的當前行號   __FILE__ 文件的完整路徑和文件名。如果用在被包含文件中，則返回被包含的文件名。   __DIR__ 文件所在的目錄。如果用在被包括文件中，則返回被包括的文件所在的目錄。它等價於 dirname(__FILE__)。除非是根目錄，否則目錄中名不包括末尾的斜杠。   __FUNCTION__ 當前函數的名稱。匿名函數則為 {closure}。   __CLASS__ 當前類的名稱。類名包括其被聲明的作用域（例如 Foo\\Bar）。當用在 trait 方法中時，__CLASS__ 是調用 trait 方法的類的名字   __TRAIT__ Trait 的名字。 Trait 名包括其被聲明的作用域（例如 Foo\\Bar）。   __METHOD__ class 的方法名   __NAMESPACE__ 當前命名空間名稱   ClassName::class 完整的 class 名稱    以下為魔術常量範例:\n\u0026lt;?php namespace UserModel { class User { public function __construct() { echo \u0026#39;I am in \u0026#39;.__CLASS__.\u0026#34;\\n\u0026#34;; } public function showData() { echo \u0026#39;I am in \u0026#39;.__METHOD__.\u0026#34;\\n\u0026#34;; } } $obj = new User; $obj-\u0026gt;showData(); echo __NAMESPACE__; } ?\u0026gt; // outputs // I am in UserModel\\User // I am in UserModel\\User::showData // UserModel PHP 運算符 算數運算符 跟國中小數學基本數學知識相同。\n\u0026lt;?php $a = 1; $b = 2; echo $a + 1 * $b; // output: 3 ?\u0026gt; 以下圖表為算術運算符\n   例子 名称 结果     +$a 標識 根據情况將 $a 轉化為 int 或 float。   -$a 取反 $a 的負值。   $a + $b 加法 $a 和 $b 的和。   $a - $b 减法 $a 和 $b 的差。   $a * $b 乘法 $a 和 $b 的積。   $a / $b 除法 $a 除以 $b 的商。   $a % $b 取模 $a 除以 $b 的餘數。   $a ** $b 求幂 $a 的 $b 次方的值。     賦值運算符 基本的賦值運算符是“=”。一開始可能會以為它是“等於”，其實不是的。它實際上意味著把右邊表達式的值賦給左邊的運算數\n下圖為算術賦值運算符\n   例子 等同於 操作     $a += $b $a = $a + $b 加法   $a -= $b $a = $a - $b 减法   $a *= $b $a = $a * $b 乘法   $a /= $b $a = $a / $b 除法   $a %= $b $a = $a % $b 取餘數   $a **= $b $a = $a ** $b 指數    下圖為其他賦值運算符\n   例子 等同於 操作     $a .= $b $a = $a . $b 字符串拼接   $a ?? $b $a = $a ?? $b NULL 合併     位元運算 位運算符允許對整型數中指定的位進行求值和操作。\n下圖為位元運算符號 | 例子 | 名稱 | 结果 | | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | | $a \u0026amp; $b | And（按位與） | 將把 $a 和 $b 中都為 1 的位設為 1。 | | $a | $b | Or（按位或） | 將把 $a 和 $b 中任何一個為 1 的位設為 1。 | | $a ^ $b | Xor（按位異或） | 將把 $a 和 $b 中一個為 1 另一個為 0 的位設為 1。 | | ~ $a | Not（按位取反） | 將 $a 中為 0 的位設為 1，反之亦然。 | | $a \u0026laquo; $b | Shift left（左移） | 將 $a 中的位向左移動 $b 次（每一次移動都表示“乘以 2”）。 | | $a \u0026raquo; $b | Shift right（右移） | 將 $a 中的位向右移動 $b 次（每一次移動都表示“除以 2”）。 |\n 比較運算符 比較運算符，如同它們名稱所暗示的，允許對兩個值進行比較。\n   例子 名稱 結果     $a == $b 等於 true，如果類型轉換後 $a 等於 $b。   $a === $b 全等於 true，如果 $a 等於 $b，並且它們的類型也相同。   $a != $b 不等於 true，如果類型轉換後 $a 不等於 $b。   $a \u0026lt;\u0026gt; $b 不等於 true，如果類型轉換後 $a 不等於 $b。   $a !== $b 不全等 true，如果 $a 不等於 $b，或者它們的類型不同。   $a \u0026lt; $b 小於 true，如果 $a 嚴格小於 $b。   $a \u0026gt; $b 大於 true，如果 $a 嚴格大於 $b。   $a \u0026lt;= $b 小於等於 true，如果 $a 小於或者等於 $b。   $a \u0026gt;= $b 大於等於 true，如果 $a 大於或者等於 $b。   $a \u0026lt;=\u0026gt; $b 太空船運算符（組合比較符） 當$a 小於、等於、大於 $b 時 分别返回一個小於、等於、大於 0 的 int 值。     執行運算符 PHP 支持一個執行運算符：反引號（``）。注意這不是單引號！ PHP 將嘗試將反引號中的內容作為 shell 命令來執行，並將其輸出信息返回（即，可以賦給一個變量而不是簡單地丟棄到標準輸出）。使用反引號運算符“`”的效果與函數 shell_exec() 相同。\n\u0026lt;?php $output = `ipconfig /all`; echo \u0026#34;\u0026lt;pre\u0026gt;$output\u0026lt;/pre\u0026gt;\u0026#34;; // 輸出所有IP資訊 ?\u0026gt;  遞增/遞減運算符 :::warning 注意: 遞增／遞減運算符不影響布爾值。遞減 null 值也沒有效果，但是遞增 null 的結果是 1。:zap: :::\n   例子 名称 效果     ++$a 先加 $a 的值加一，然後返回 $a。   $a++ 後加 返回 $a，然後將 $a 的值加一。   \u0026ndash;$a 先减 $a 的值减一， 然后返回 $a。   $a\u0026ndash; 後减 返回 $a，然後將 $a 的值减一。    簡易的範例\n\u0026lt;?php echo \u0026#34;後增量(PostIncrement)\\n\u0026#34;; $a = 5; echo \u0026#34;Should be 5: \u0026#34; . $a++ . \u0026#34;\u0026lt;br /\u0026gt;\\n\u0026#34;; echo \u0026#34;Should be 6: \u0026#34; . $a . \u0026#34;\u0026lt;br /\u0026gt;\\n\u0026#34;; echo \u0026#34;先增量(PreIncrement)\\n\u0026#34;; $a = 5; echo \u0026#34;Should be 6: \u0026#34; . ++$a . \u0026#34;\u0026lt;br /\u0026gt;\\n\u0026#34;; echo \u0026#34;Should be 6: \u0026#34; . $a . \u0026#34;\u0026lt;br /\u0026gt;\\n\u0026#34;; echo \u0026#34;後減(PostDecrement)\\n\u0026#34;; $a = 5; echo \u0026#34;Should be 5: \u0026#34; . $a-- . \u0026#34;\u0026lt;br /\u0026gt;\\n\u0026#34;; echo \u0026#34;Should be 4: \u0026#34; . $a . \u0026#34;\u0026lt;br /\u0026gt;\\n\u0026#34;; echo \u0026#34;先減(Predecrement)\\n\u0026#34;; $a = 5; echo \u0026#34;Should be 4: \u0026#34; . --$a . \u0026#34;\u0026lt;br /\u0026gt;\\n\u0026#34;; echo \u0026#34;Should be 4: \u0026#34; . $a . \u0026#34;\u0026lt;br /\u0026gt;\\n\u0026#34;; ?\u0026gt;  邏輯運算符    例子 名稱 结果     $a and $b And（和） true，如果 $a 和 $b 都為 true。   $a or $b Or（或） true，如果 $a 或 $b 任一為 true。   $a xor $b Xor（異或） true，如果 $a 或 $b 任一為 true，但不同時是。   ! $a Not（非） true，如果 $a 不為 true。   $a \u0026amp;\u0026amp; $b And（與） true，如果 $a 和 $b 都為 true。   $a || $b Or（或） true，如果 $a 或 $b 任一為 true。     字符串運算符 有兩個字符串（string）運算符。第一個是連接運算符（“.”），它返回其左右參數連接後的字符串。第二個是連接賦值運算符（“.=”），它將右邊參數附加到左邊的參數之後。\n範例程式碼\n\u0026lt;?php $a = \u0026#34;Hello \u0026#34;; $b = $a . \u0026#34;World!\u0026#34;; echo $b.\u0026#34;\\n\u0026#34;; // output \u0026#34;Hello World!\u0026#34;  $a = \u0026#34;Hello \u0026#34;; $a .= \u0026#34;World!\u0026#34;; // output \u0026#34;Hello World!\u0026#34; echo $a; ?\u0026gt;  數組運算符    例子 名稱 结果     $a + $b 聯合 $a 和 $b 的联合。   $a == $b 相等 如果 $a 和 $b 具有相同的键／值，則為 true。   $a === $b 全等 如果 $a 和 $b 具有相同的键／值，並且順序和類型都相同則為 true。   $a != $b 不等於 如果 $a 不等於 $b 則為 true。   $a \u0026lt;\u0026gt; $b 不等於 如果 $a 不等於 $b 則為 true。   $a !== $b 不相等 如果 $a 不全等於 $b 則為 true。    如果是運用運算符將數組相加，會把加號右邊的附加到加號左邊數組， 兩個數組中都有的鍵名，則只用左邊數組中的，右邊的被忽略\n以下簡單範例示範:\n\u0026lt;?php $a = array(\u0026#34;a\u0026#34; =\u0026gt; \u0026#34;apple\u0026#34;, \u0026#34;b\u0026#34; =\u0026gt; \u0026#34;banana\u0026#34;); $b = array(\u0026#34;a\u0026#34; =\u0026gt; \u0026#34;pear\u0026#34;, \u0026#34;b\u0026#34; =\u0026gt; \u0026#34;strawberry\u0026#34;, \u0026#34;c\u0026#34; =\u0026gt; \u0026#34;cherry\u0026#34;); $c = $a + $b; // Union of $a and $b var_dump($c); $c = $b + $a; // Union of $b and $a var_dump($c); // 輸出: // array(3) { // [\u0026#34;a\u0026#34;]=\u0026gt; // string(5) \u0026#34;apple\u0026#34; // [\u0026#34;b\u0026#34;]=\u0026gt; // string(6) \u0026#34;banana\u0026#34; // [\u0026#34;c\u0026#34;]=\u0026gt; // string(6) \u0026#34;cherry\u0026#34; // }  // array(3) { // [\u0026#34;a\u0026#34;]=\u0026gt; // string(4) \u0026#34;pear\u0026#34; // [\u0026#34;b\u0026#34;]=\u0026gt; // string(10) \u0026#34;strawberry\u0026#34; // [\u0026#34;c\u0026#34;]=\u0026gt; // string(6) \u0026#34;cherry\u0026#34; // } ?\u0026gt; 以下示範比較數組\n\u0026lt;?php $a = array(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;); $b = array(1 =\u0026gt; \u0026#34;banana\u0026#34;, \u0026#34;0\u0026#34; =\u0026gt; \u0026#34;apple\u0026#34;); var_dump($a == $b); // bool(true) var_dump($a === $b); // bool(false) ?\u0026gt;  類型運算符 instanceof 方法用於確定一個 PHP 變數是否屬於某一類 class 的實例， 也可以用來確認某一個變數，是否繼承自某一父類或子類的實例。\n以下範例\n\u0026lt;?php class MyClass { } class NotMyClass { } $a = new MyClass; var_dump($a instanceof MyClass); var_dump($a instanceof NotMyClass); ?\u0026gt; // 輸出 // bool(True) // bool(False)  PHP 流程控制 If Else 判斷句 If 可以使用在判斷某條件達成時執行語句，else 則是在不滿該條下執行。\n以下使用範例示範\n\u0026lt;?php if ($a \u0026gt; $b){ console.log(\u0026#34;a win\u0026#34;); }else { console.log(\u0026#34;b win\u0026#34;); } ?\u0026gt;  else if 判斷句 是 if 語句的延伸，可以在原來的 if 表達式值為 false 時執行不同語句。但是和 else 不一樣的是，它僅在 elseif 的條件表達式值為 true 時執行語句。\n以下使用範例示範:\n\u0026lt;?php if($a \u0026gt; $b){ echo \u0026#34;a is bigger than b\u0026#34;; } elseif($a == $b){ echo \u0026#34;a is equal to b\u0026#34;; }else{ echo \u0026#34;a is smaller than b\u0026#34;; } ?\u0026gt;  while 迴圈 只要條件成立就會重複執行語句，表達式在每次開始循環前檢查，所以即使值在循環語句中改變，語句也不會停止執行，值到此次循環結束。\n如果 while 表達式一開始的值為 false，則循環語句一次都不會執行。\n\u0026lt;?php $i = 1; while ($i \u0026lt;= 10) { // i \u0026gt; 10停止迴圈  echo $i++; // 先輸出 i 後再加一 } ?\u0026gt;  do-while 迴圈 和 while 迴圈相似，差別在於表達式的檢查是在循環結束時才檢查，所以 do-while 語句一定會執行循環語句一次。\n以下範例:\n\u0026lt;?php $i = 0; do{ echo $i; } while($i\u0026lt;0); ?\u0026gt; 剛好執行一次後停下，因為條件不符合。\n for 迴圈 for 迴圈的語法是:\nfor (expr1; expr2; expr3) statement expr1:此表達式會在執行前，無條件執行一次。\nexpr2:在每次循環開始前求值。如果值為 true，則繼續循環，執行 statement 的循環語句。如果值為 false，則終止循環。\nexpr3:在循環之後，賦值(並執行)\n以下所有範例為顯示 1~10 數字:\n\u0026lt;?php /* example 1 */ for ($i = 1; $i \u0026lt;= 10; $i++) { echo $i; } /* example 2 */ for ($i=1; ; $i++){ if　($i \u0026gt; 10){ break; } echo $i; } /* example 3 */ for (;;){ if ($i \u0026gt; 10) { break; } echo $i; $i++; } /* example 4 */ for ($i = 1, $j = 0; $i \u0026lt;= 10; $j += $i, print $i, $i++); ?\u0026gt;  foreach foreach 語法結構提供了可以遍歷 array 的簡單方式，foreach 只能用於 array 和 object，用於其他數據類型的變數，會發出錯誤。\nforeach 語法如下:\nforeach (iterable_expression as $value) statement foreach (iterable_expression as $key =\u0026gt; $value) statement 第一種格式遍歷，會將 iterable_expression 內的值賦予給$value。\n第二種格式遍歷與第一種相似，但會在每次循環將當前的鍵值賦予給$key。\n以下為範例:\n\u0026lt;?php /* foreach example 1: value only */ $arr = array(2, 4, 6, 8); foreach($arr as $value){ echo \u0026#34;value = $value\\n\u0026#34;; } /* foreach example 2: key and value */ $arr = array( \u0026#34;name\u0026#34; =\u0026gt; \u0026#34;joe\u0026#34;, \u0026#34;cel\u0026#34; =\u0026gt; 1234567, \u0026#34;address\u0026#34; =\u0026gt; \u0026#34;Taiwan\u0026#34; ); foreach($arr as $key =\u0026gt; $value){ echo \u0026#34;$key=\u0026gt; $value\\n\u0026#34;; } ?\u0026gt; /* foreach example 3: dynamic arrays */ foreach (array(2, 4, 6, 8, 10) as $v) { echo \u0026#34;$v\\n\u0026#34;; } 用 list() 給嵌套的數組解包\n可以遍歷一個數組的數組並且把嵌套的數組解包到循環變量中，只需將 list() 作為值提供。\n\u0026lt;?php $array = [ [1, 2], [3, 4], ]; foreach ($array as list($a, $b)) { // $a contains the first element of the nested array,  // and $b contains the second element.  echo \u0026#34;A: $a; B: $b\\n\u0026#34;; } ?\u0026gt; 範例輸出:\nA: 1; B: 2 A: 3; B: 4 list() 中的單元可以少於嵌套數組的，此時多出來的數組單元將被忽略，如果 list 中單元多於嵌套數組，則會報錯：\n\u0026lt;?php $array = [ [1, 2], [3, 4], ]; foreach ($array as list($a)) { // Note that there is no $b here.  echo \u0026#34;A: $a;\\n\u0026#34;; } ?\u0026gt; 輸出\nA: 1; A: 3;  break break 結束當前 for，foreach，while，do-while 或者 switch 結構的執行。\nbreak 可以接受一個可選參數，來決定要跳出幾層迴圈。\n以下為範例:\n\u0026lt;?php $arr = array(\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;stop\u0026#39;, \u0026#39;five\u0026#39;); // 使用each() 和list() 結合用來遍歷數組 while (list (, $val) = each($arr)) { if ($val == \u0026#39;stop\u0026#39;) { break; /* You could also write \u0026#39;break 1;\u0026#39; here. */ } echo \u0026#34;$val\u0026lt;br /\u0026gt;\\n\u0026#34;; } /* 使用可選参数 */ $i = 0; while (++$i) { switch ($i) { case 5: echo \u0026#34;At 5\u0026lt;br /\u0026gt;\\n\u0026#34;; break 1; /* 只退出 switch. */ case 10: echo \u0026#34;At 10; quitting\u0026lt;br /\u0026gt;\\n\u0026#34;; break 2; /* 退出 switch 和 while 循环 */ default: break; } } ?\u0026gt;  continue continue 在循環結構用用來跳過本次循環中剩餘的代碼並在條件求值為真時開始執行下一次循環。\n以下為範例:\n\u0026lt;?php for($i=1; $i\u0026lt;5; $i++){ if($i==2){ continue; } echo \u0026#34;$i\\n\u0026#34;; // outputs: 1 3 4 } ?\u0026gt;  switch switch 語句類似於具有同一個表達式的一系列 if 語句。很多情況下需要把同一個變數（或表達式）與很多不同的值比較，並根據它等於哪個值來執行不同的代碼。\n以下為範例，利用 if/else if 和 switch 實現不同方法實現相同的事:\n\u0026lt;?php if ($i == 0) { echo \u0026#34;i equals 0\u0026#34;; } elseif ($i == 1) { echo \u0026#34;i equals 1\u0026#34;; } elseif ($i == 2) { echo \u0026#34;i equals 2\u0026#34;; } switch ($i) { case 0: echo \u0026#34;i equals 0\u0026#34;; break; case 1: echo \u0026#34;i equals 1\u0026#34;; break; case 2: echo \u0026#34;i equals 2\u0026#34;; break; } ?\u0026gt; 一個 case 的特例是 default。它匹配了任何和其它 case 都不匹配的情況。例如：\n\u0026lt;?php switch ($i) { case 0: echo \u0026#34;i equals 0\u0026#34;; break; case 1: echo \u0026#34;i equals 1\u0026#34;; break; case 2: echo \u0026#34;i equals 2\u0026#34;; break; default: echo \u0026#34;i is not equal to 0, 1 or 2\u0026#34;; } ?\u0026gt;  match 與 switch 語句類似， match 表達式具有與多個備選方案進行比較的主題表達式，與 switch 不同，它將計算為一個很像三元表達式的值。與 switch 不同的是，比較的是強型別相等檢查 (===) 而不是弱型別相等檢查 (==)。匹配表達式從 PHP 8.0.0 開始可用。\n範例如下:\n\u0026lt;?php $age = 23; $result = match (true) { $age \u0026gt;= 65 =\u0026gt; \u0026#39;senior\u0026#39;, $age \u0026gt;= 25 =\u0026gt; \u0026#39;adult\u0026#39;, $age \u0026gt;= 18 =\u0026gt; \u0026#39;young adult\u0026#39;, default =\u0026gt; \u0026#39;kid\u0026#39;, }; var_dump($result); echo($result); ?\u0026gt; // outputs: // string(11) \u0026#34;young adult\u0026#34; // young adult  declare  declare 不是一個函數，算是一個語言結構\n declare 用來設定一段 code 的執行指令。\ndeclare (directive) statement directive 的部分允許設定 declare 代碼段的行為。\n如果 declare 語句後面沒有括號，則該指令適用於文件中的其餘代碼。 以下為範例:\n\u0026lt;?php // 兩個相等：  // 可以這樣用： declare(ticks=1) { // 這裡寫腳本 } // 也可以這樣用： declare(ticks=1); // 這裡寫腳本 ?\u0026gt; declare 指令是在文件編譯時處理的，所以指令只接受字面量的值。 無法使用變量和常量。下面為範例程式碼:\n\u0026lt;?php // 有效程式碼： declare(ticks=1); // 無效，無法指定常量： const TICK_VALUE = 1; declare(ticks=TICK_VALUE); ?\u0026gt; 可以聲明三個指令：ticks,encoding 和 strict_types.\nticks 每次執行指定數量(N)可計時的指令時，該指令都會發送一個 tick 事件。可以使用 register_tick_function() ，它會在每次 event 事件觸發時運行。\n不是所有語句都可計時。通常條件表達式和參數表達式都不可計時。\n以下為範例:\n\u0026lt;?php declare(ticks=1); // 每次 tick 事件都會調用此函数 function tick_handler() { echo \u0026#34;tick_handler() called\\n\u0026#34;; } register_tick_function(\u0026#39;tick_handler\u0026#39;); $a = 1; if ($a \u0026gt; 0) { $a += 2; print($a); } ?\u0026gt; 該 encoding 指令用於指示文件使用的字符編碼。它不能用於塊，它必須應用於整個文件。\n\u0026lt;?php declare(encoding=\u0026#39;ISO-8859-1\u0026#39;); // code here ?\u0026gt; 當 strict_types 指令設置，錯誤類型傳遞到函數參數時不會被強制轉換為正確的類型，而是拋出致命錯誤。\n範例如下:\n// 正常情況下 \u0026lt;?php function add(int $a, int $b): int { return $a + $b; } var_dump(add(1.0, 1.0)); // output // int(2) 當使用 strict_types 後，變成強型別\n\u0026lt;?php declare(strict_types=1); //加入这句  function add(int $a, int $b): int { return $a + $b; } var_dump(add(1.0, 1.0)); // 拋出TypeError:必須為integer整數  return return 將程序控制返還給調用模塊。將在調用模塊中執行的下一句表達式中繼續。\n如果在一個函數中調用 return 語句，將立即結束此函數的執行並將它的參數作為函數的值返回。 return 也會終止 eval() 語句或者腳本文件的執行\neval(): 把字符串作為 PHP 代碼執行\n require require 和 include 幾乎完全一樣，除了處理失敗的方式不同之外。 require 在出錯時產生 E_COMPILE_ERROR 級別的錯誤。換句話說將導致腳本中止而 include 只產生警告（E_WARNING），腳本會繼續運行。\n include include 語句包含並運行指定文件。\n以下也適用於 require。\n被包含文件先按參數給出的路徑尋找，如果沒有給出目錄（只有文件名）時則按照 include_path 指定的目錄尋找。如果在 include_path 下沒找到該文件則 include 最後才在調用腳本文件所在的目錄和當前工作目錄下尋找。如果最後仍未找到文件則 include 結構會發出一條警告；這一點和 require 不同，後者會發出一個致命錯誤。\n基本 include 用法:\nvars.php \u0026lt;?php $color = \u0026#39;red\u0026#39;; $car = \u0026#39;vovlo\u0026#39;; ?\u0026gt; test.php \u0026lt;?php echo \u0026#34;A $color$car\u0026#34;; // A  include \u0026#39;vars.php\u0026#39;; echo \u0026#34;A $color$car\u0026#34;; // A red vovlo  ?\u0026gt; include 和 return 語句\nreturn.php \u0026lt;?php $var = \u0026#39;PHP\u0026#39;; return $var; ?\u0026gt; noreturn.php \u0026lt;?php $var = \u0026#39;PHP\u0026#39;; ?\u0026gt; testreturns.php \u0026lt;?php $foo = include \u0026#39;return.php\u0026#39;; echo $foo; // 輸出 \u0026#39;PHP\u0026#39;  $bar = include \u0026#39;noreturn.php\u0026#39;; echo $bar; // 輸出 1(因為成功返回true = 1)  ?\u0026gt;  require_once require_once 語句和 require 語句完全相同，唯一區別是 PHP 會檢查該文件是否已經被包含過，如果是則不會再次包含。\n include_once include_once 語句在腳本執行期間包含並運行指定文件。此行為和 include 語句類似，唯一區別是如果該文件中已經被包含過，則不會再次包含，且 include_once 會返回 true。如同此語句名字暗示的那樣，該文件只會包含一次。 include_once 可以用於在腳本執行期間同一個文件有可能被包含超過一次的情況下，想確保它只被包含一次以避免函數重定義，變量重新賦值等問題。\nPHP 函數 自定義函數 函數可用以下語法來定義\n\u0026lt;?php function foo($arg_1, $arg_2, /* ..., */ $arg_n) { echo \u0026#34;Example function.\\n\u0026#34;; return $retval; } ?\u0026gt; 函數不需要在使用之前被定義，除非是函數是有條件被定義時，才必須在使用前定義\n舉以下範例\n 有條件的函數:  \u0026lt;?php $makefoo = true; /* 不能在此處調用foo()函數， 因為它還不存在，但可以調用bar()函數。*/ bar(); if ($makefoo) { function foo() { echo \u0026#34;I don\u0026#39;t exist until program execution reaches me.\\n\u0026#34;; } } /* 現在可以安全調用函數 foo() 因為 $makefoo 值為真true */ if ($makefoo) foo(); function bar() { echo \u0026#34;I exist immediately upon program start.\\n\u0026#34;; } ?\u0026gt; 函數中的函數  \u0026lt;?php function foo() { function bar() { echo \u0026#34;I don\u0026#39;t exist until foo() is called.\\n\u0026#34;; } } /* 現在還不能調用 bar() 函數，因為它還不存在 */ foo(); /* 現在可以調用 bar() 函數了，因為 foo() 函數的執行使得 bar() 函數變為已定義的函數 */ bar(); ?\u0026gt; :::warning PHP 中的所有函數和類都具有全局作用域，可以定義在一個函數之內而在之外調用，反之亦然。 PHP 不支持函數重載，也不可能取消定義或者重定義已聲明的函數。 :::\n還有遞迴函數，也就是自己呼叫自己\n舉個費氏數列的例子(從 0,1 開始，後面的數是前兩個數相加)\n\u0026lt;?php function fib($n) { if($n == 0) return 0; if($n == 1) return 1; return fib($n-1) + fib($n - 2); } for($i = 0; $i \u0026lt;= 5; $i++){ echo fib(\u0026#34;$i\u0026#34;); } // outputs // 0,1,1,2,3,5 :::danger 注意: 但是要避免遞歸函數／方法調用超過 100-200 層，因為可能會使堆積崩潰從而使當前腳本終止。無限遞歸可視為編程錯誤 :::\n 函數的參數 通過給予函數參數，傳遞訊息給函數，可以放入多個參數用逗號分隔，也可以設置參數默認的值。\n1. 向函數傳遞 array: \u0026lt;?php function takes_array($nums) { echo \u0026#39;$nums[0] + $nums[1] = \u0026#39;, $nums[0] + $nums[1]; } 從 php8 開始參數尾巴逗號是會被忽略的\n2. 使用尾巴逗號 \u0026lt;?php function takes_many_args( $first_name, $last_name, $age, $gender = 1, $cellphone = null, // 在 8.0.0 之前，尾部逗號是不允许的。 ) { // ... } ?\u0026gt; 從 PHP 8.0.0 開始，不推薦在可選參數之後傳遞強制參數。 這通常可以通過刪除默認值來解決。 此規則的一個例外是 Type $param = null 形式的參數，其中 null 默認值使類型隱式可為空。 這種用法仍然被允許，但建議改用顯式可為空類型。\n3. 在強制參數之後傳遞可選參數 \u0026lt;?php function foo($a = [], $b) {} // 之前 function foo($a, $b) {} // 之後  function bar(A $a = null, $b) {} // 同時可用 function bar(?A $a, $b) {} // 官方推薦 ?\u0026gt; 4. 在函數中使用默認參數 PHP 還允許使用數組 array 和特殊類型 null 作為默認參數。\n\u0026lt;?php function makecoffee($type = \u0026#34;cappuccino\u0026#34;) { return \u0026#34;Making a cup of $type.\\n\u0026#34;; } echo makecoffee(); echo makecoffee(null); echo makecoffee(\u0026#34;espresso\u0026#34;); ?\u0026gt; // outputs // Making a cup of cappuccino. // Making a cup of . // Making a cup of espresso. 5. 函數默認參數的不正確用法 默認值必須是常量表達式，不能是，如變量，類成員，或者函數調用等。 注意當使用默認參數時，任何默認參數必須放在任何非默認參數的右側；否則，函數將不會按照預期的情況工作。\n\u0026lt;?php function makeyogurt($type = \u0026#34;acidophilus\u0026#34;, $flavour) { return \u0026#34;Making a bowl of $type$flavour.\\n\u0026#34;; } echo makeyogurt(\u0026#34;raspberry\u0026#34;); // won\u0026#39;t work as expected ?\u0026gt; // Warning: Missing argument 2 in call to makeyogurt() 6. 函數默認參數正確用法 \u0026lt;?php function makeyogurt($flavour, $type = \u0026#34;acidophilus\u0026#34;) { return \u0026#34;Making a bowl of $type$flavour.\\n\u0026#34;; } echo makeyogurt(\u0026#34;raspberry\u0026#34;); // works as expected ?\u0026gt; // outputs // Making a bowl of acidophilus raspberry. 7. 使用 \u0026hellip; 來訪問變量參數 PHP 在用戶自定義函數中支持可變數量的參數列表。由 \u0026hellip; 語法實現。\n包含 \u0026hellip; 的參數，會轉換為指定參數變量的一個數組(類似字典)，以下示例：\n\u0026lt;?php function sum(...$numbers) { $acc = 0; foreach ($numbers as $n) { $acc += $n; } return $acc; } echo sum(1, 2, 3, 4); ?\u0026gt; // 10 8. 使用\u0026hellip;來傳遞參數 \u0026lt;?php function add($a, $b) { return $a + $b; } echo add(...[1, 2]).\u0026#34;\\n\u0026#34;; $a = [1, 2]; echo add(...$a); ?\u0026gt; // 3 // 3 9. 輸入提示的變量參數 \u0026lt;?php function total_intervals($unit, DateInterval ...$intervals) { // 必須傳遞DateInterval類的參數  $time = 0; foreach ($intervals as $interval) { $time += $interval-\u0026gt;$unit; } return $time; } $a = new DateInterval(\u0026#39;P1D\u0026#39;); $b = new DateInterval(\u0026#39;P2D\u0026#39;); echo total_intervals(\u0026#39;d\u0026#39;, $a, $b).\u0026#39; days\u0026#39;; // This will fail, since null isn\u0026#39;t a DateInterval object. echo total_intervals(\u0026#39;d\u0026#39;, null); ?\u0026gt; // outputs // 3 days // Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, // null given, called in - on line 14 and defined in - on line 2 命名函數 PHP 8.0.0 開始引入了命名參數作為現有位置參數的擴展。命名參數允許根據參數名而不是參數位置向函數傳參。這使得參數的含義自成體系，參數與順序無關，並允許任意跳過默認值。\n命名參數通過在參數名前加上冒號來傳遞。允許使用保留關鍵字作為參數名。參數名必須是一個標識符，不允許動態指定。\n10. 命名參數語法 \u0026lt;?php function myFunction($paramName){ echo $paramName; } myFunction(paramName: $value); // $value指定給予paramName這個參數 array_foobar(array: $value); // NOT supported. function_name($variableStoringParamName: $value); // 不能動態指定 ?\u0026gt; 11. 通過位置傳參與命名參數的對比 \u0026lt;?php // 使用順序傳遞： array_fill(0, 100, 50); // 使用命名參數： array_fill(start_index: 0, count: 100, value: 50); ?\u0026gt; 順序不重要，下面輸出跟上面一樣\n\u0026lt;?php array_fill(value: 50, count: 100, start_index: 0); ?\u0026gt; 12. 不可多次傳遞給同一個參數 \u0026lt;?php function foo($param) { ... } foo(param: 1, param: 2); // Error: Named parameter $param overwrites previous argument foo(1, param: 2); // Error: Named parameter $param overwrites previous argument ?\u0026gt;  返回值 return 值通過使用可選的返回語句返回。可以返回包括數組和對象的任意類型。返回語句會立即中止函數的運行，並且將控制權交回調用該函數的代碼行\n:::warning 如果省略了 return，則返回值為 null。 :::\n1. 基礎語法 \u0026lt;?php function square($num) { return $num * $num; } echo square(5); // outputs \u0026#39;25\u0026#39;. ?\u0026gt; 2. 返回一個數組以得到多個返回值 函數不能返回多個值，但可以通過返回一個數組來得到類似的效果。\n\u0026lt;?php function small_numbers() { return [0, 1, 2]; } // 使用短數組語法將数组中的值賦给一組變數 [$zero, $one, $two] = small_numbers(); // 在 7.1.0 之前，唯一相等的選擇是使用 list() 結構 list($zero, $one, $two) = small_numbers(); ?\u0026gt; 3. 返回一個引用 從函數返回一個引用，必須在函數聲明和指派返回值給一個變量時都使用引用運算符 \u0026amp;\n\u0026lt;?php function \u0026amp;returns_reference() { return $someref; } $newref =\u0026amp; returns_reference(); ?\u0026gt;  可變函數 PHP 支持可變函數的概念。就是說如果一個變量名後有圓括號，PHP 就會先去尋找這個變數名稱的函數執行。可變函數可以用來實現包括回調函數，以及函數表在內的一些用途。\n來看看範例\n1. 可變函數示例 \u0026lt;?php function foo() { echo \u0026#34;In foo()\u0026lt;br /\u0026gt;\\n\u0026#34;; } function bar($arg = \u0026#39;\u0026#39;) { echo \u0026#34;In bar(); argument was \u0026#39;$arg\u0026#39;.\u0026lt;br /\u0026gt;\\n\u0026#34;; } // 使用名為 echo 的函數 function echoit($string) { echo $string; } $func = \u0026#39;foo\u0026#39;; $func(); // This calls foo()  $func = \u0026#39;bar\u0026#39;; $func(\u0026#39;test\u0026#39;); // This calls bar()  $func = \u0026#39;echoit\u0026#39;; $func(\u0026#39;test\u0026#39;); // This calls echoit() ?\u0026gt; 2. 可變方法範例 \u0026lt;?php class Foo { function Variable() { $name = \u0026#39;Bar\u0026#39;; $this-\u0026gt;$name(); // This calls the Bar() method  } function Bar() { echo \u0026#34;This is Bar\u0026#34;; } } $foo = new Foo(); $funcname = \u0026#34;Variable\u0026#34;; $foo-\u0026gt;$funcname(); // This calls $foo-\u0026gt;Variable()  ?\u0026gt; 3. Variable 方法和靜態屬性範例 當調用靜態方法時，函數調用要比靜態屬性優先\n\u0026lt;?php class Foo { static $variable = \u0026#39;static property\u0026#39;; static function Variable() { echo \u0026#39;Method Variable called\u0026#39;; } } echo Foo::$variable; // This prints \u0026#39;static property\u0026#39;. It does need a $variable in this scope. $variable = \u0026#34;Variable\u0026#34;; Foo::$variable(); // This calls $foo-\u0026gt;Variable() reading $variable in this scope.  ?\u0026gt; 4. 複雜的可調用對象 \u0026lt;?php class Foo { static function bar() { echo \u0026#34;bar\\n\u0026#34;; } function baz() { echo \u0026#34;baz\\n\u0026#34;; } } $func = array(\u0026#34;Foo\u0026#34;, \u0026#34;bar\u0026#34;); $func(); // prints \u0026#34;bar\u0026#34; $func = array(new Foo, \u0026#34;baz\u0026#34;); $func(); // prints \u0026#34;baz\u0026#34; $func = \u0026#34;Foo::bar\u0026#34;; $func(); // prints \u0026#34;bar\u0026#34;  // 這樣可是會出錯的哦，沒有先實體化類別 $func = array(\u0026#34;Foo\u0026#34;, \u0026#34;baz\u0026#34;); $func(); // Uncaught Error: Non-static method Foo::baz() cannot be called statically in .... ?\u0026gt;  内部（内置）函数 PHP 有很多標準的函數和結構。還有一些函數需要和特定地 PHP 擴展模塊一起編譯，否則在使用它們的時候就會得到一個致命的“未定義函數”錯誤。\n例如要連接 MySQL，要使用 mysqli_connect() 函數，就需要在編譯 PHP 的時候加上 MySQLi 支持。可以使用 phpinfo() 或者 get_loaded_extensions() 可以得知 PHP 加載了那些擴展庫\n 匿名函数 匿名函數（Anonymous functions），也稱作閉包函數（closures），它允許臨時創建一個沒有指定名稱的函數。最經常用作回調函數 callable 參數的值。當然，也有其它應用的情況。\n1. 匿名函數範例 \u0026lt;?php // 使用回調執行正則表達式搜索和替換 echo preg_replace_callback(\u0026#39;~-([a-z])~\u0026#39;, function ($match) { return strtoupper($match[1]); // 將所選的變成大寫，從index: 1開始過濾掉原先\u0026#34;-\u0026#34; }, \u0026#39;hello-world\u0026#39;); // 输出 helloWorld ?\u0026gt; 閉包函數也可以作為變量的值來使用。 PHP 會自動把此種表達式轉換成內置類 Closure 的對象實例。把一個 closure 對象賦值給一個變量的方式與普通變量賦值的語法是一樣的，最後也要加上分號 ；\n2. 匿名函數變量賦值示例 \u0026lt;?php $sayHi = function($name) { echo \u0026#34;Hello $name\u0026#34;; }; // 記得加上分號  $sayHi(\u0026#39;joe\u0026#39;); $sayHi(\u0026#39;cherry\u0026#39;); ?\u0026gt; 3. 從父作用域繼承變數 閉包可以從父作用域中繼承變量。任何此類變量都應該用 use 語言結構傳遞進去。\nPHP 7.1 起，不能傳入此類變量： superglobals(超全局便量)、 $this 或者和參數重名。\n從 PHP 8.0.0 開始，作用域繼承的變量列表可能包含一個尾部的逗號，這個逗號將被忽略\n\u0026lt;?php $message = \u0026#39;hello\u0026#39;; // 没有 \u0026#34;use\u0026#34; php會不知道這變數從哪來 $example = function () { var_dump($message); }; $example(); // 繼承父作用域 $message $example = function () use ($message) { var_dump($message); }; $example(); // Inherited variable\u0026#39;s value is from when the function // is defined, not when called $message = \u0026#39;world\u0026#39;; $example(); // 不會受到改變因為已經在上面先調用了(14行)  // Reset message $message = \u0026#39;hello\u0026#39;; // Inherit by-reference $example = function () use (\u0026amp;$message) { var_dump($message); }; $example(); // The changed value in the parent scope // is reflected inside the function call // 父作用域更改值，影響函式回調 $message = \u0026#39;world\u0026#39;; $example(); // Closures can also accept regular arguments // 閉包可使用常規變數 $example = function ($arg) use ($message) { var_dump($arg . \u0026#39; \u0026#39; . $message); }; $example(\u0026#34;hello\u0026#34;); ?\u0026gt; // outputs // Notice: Undefined variable: ... // NULL // string(5) \u0026#34;hello\u0026#34; // string(5) \u0026#34;hello\u0026#34; // string(5) \u0026#34;hello\u0026#34; // string(5) \u0026#34;world\u0026#34; // string(11) \u0026#34;hello world\u0026#34;  箭頭函數 箭頭函數是更簡潔的匿名函數，都是屬於 Closure 類(閉包)的實現\n箭頭函數的語法為 fn (argument_list) =\u0026gt; expr。\n箭頭函數支持與 匿名函數 相同的功能，只是其父作用域的變量總是自動的。 當表達式中使用的變量是在父作用域中定義的，它將被隱式地按值捕獲。\n在下面的例子中，函數 $fn1 和 $fn2 的行為是一樣的\n1. 箭頭函數自動捕捉變數的值 \u0026lt;?php $y = 1; $fn1 = fn($x) =\u0026gt; $x + $y; // 相當於 using $y by value: $fn2 = function ($x) use ($y) { return $x + $y; }; // var_export -- 輸出或返回一個變量的字串表示 var_export($fn1(3)); // 4 ?\u0026gt; 2. 箭頭函數自動捕捉變量的值，即使在嵌套的情況下 通常在 A 程序執行中，尚未結束前又開始執行 B 程序，B 程序結束後，繼續執行 A 程序，就稱為嵌套。\n\u0026lt;?php $z = 1; $fn = fn($x) =\u0026gt; fn($y) =\u0026gt; $x * $y + $z; // 輸出 21 var_export($fn(5)(4)); ?\u0026gt; 3. 箭頭函數有效用法例子 和匿名函數一樣，箭頭函數語法同樣允許標準的函數聲明，包括參數和返回類型、缺省值、變量，以及通過引用傳遞和返回。以下都是箭頭函數的有效例子。\n\u0026lt;?php fn(array $x) =\u0026gt; $x; static fn(): int =\u0026gt; $x; fn($x = 42) =\u0026gt; $x; fn(\u0026amp;$x) =\u0026gt; $x; fn\u0026amp;($x) =\u0026gt; $x; fn($x, ...$rest) =\u0026gt; $rest; ?\u0026gt; 4. 來自外部範圍的值不能在箭頭函數內修改 箭頭函數會自動綁定上下文變量，這相當於對箭頭函數內部使用的每一個變量 $x 執行了一個 use($x)。這意味著不可能修改外部作用域的任何值，若要實現對值的修改，可以使用 匿名函數 來替代。\n\u0026lt;?php $x = 1; $fn = fn() =\u0026gt; $x++; // 不會影響 x 的值 $fn(); var_export($x); // 輸出 1  ?\u0026gt; class 類 class 基本 每個類的定義都以關鍵字 class 開頭，後面跟著類的名，再一個括號，裡面包含有類的屬性與方法的定義。\n一個類可以包含有屬於自己的 常量，變量（稱為“屬性”）以及函數（稱為“方法”）。\n當要調用內部屬性或方法時可以使用$this，$this 是一個到當前對象的引用。\n1. 簡單的類定義 \u0026lt;?php class SimpleClass { // 聲明屬性  public $var = \u0026#39;a default value\u0026#39;; // 聲明方法  public function displayVar() { echo $this-\u0026gt;var; } } ?\u0026gt; new 要創建一個類的實例，必須使用 new 關鍵字。當創建新對象時該對象總是被賦值，除非該對象定義了 構造函數 並且在出錯時拋出了一個 異常。\n構造函數 : 類中的一個特殊函數，當使用 new 操作符創建一個類的實例時，構造函數將會自動調用。當函數與類同名時，這個函數將成為構造函數。如果一個類沒有構造函數，則調用基類的構造函數，如果有的話\n類應在被實例化之前定義（某些情況下則必須這樣）。\n如果在 new 之後跟著的是一個包含有類名的字符串 string，則該類的一個實例被創建。如果該類屬於一個命名空間，則必須使用其完整名稱。\n:::warning 如果沒有參數要傳遞給類的構造函數，類名後的括號則可以省略掉。 :::\n2. 創建實例 \u0026lt;?php $instance = new SimpleClass(); // 也可以這樣做： $className = \u0026#39;SimpleClass\u0026#39;; $instance = new $className(); // new SimpleClass() ?\u0026gt; 3. 創建新對象 \u0026lt;?php class Test { static public function getNew() { return new static; } } class Child extends Test {} $obj1 = new Test(); $obj2 = new $obj1; var_dump($obj1 !== $obj2); $obj3 = Test::getNew(); var_dump($obj3 instanceof Test); $obj4 = Child::getNew(); var_dump($obj4 instanceof Child); ?\u0026gt; // outputs // bool(true) // bool(true) // bool(true) 屬性和方法 類的屬性和方法存在於不同的“命名空間”中，這代表說同一個類的屬性和方法可以使用同樣的名字。在類中訪問屬性和調用方法使用同樣的操作符，那到底是訪問一個屬性還是調用一個方法，取決於你的上下文，即用法是變數的訪問還是函數的調用。\n4. 訪問類屬性 vs. 調用類方法 \u0026lt;?php class Foo { public $bar = \u0026#39;property\u0026#39;; public function bar() { return \u0026#39;method\u0026#39;; } } $obj = new Foo(); echo $obj-\u0026gt;bar, PHP_EOL, $obj-\u0026gt;bar(), PHP_EOL; // PHP_EOL: php換行符號  // property // method ?\u0026gt; 5. 類屬性被賦值為匿名函數時的調用示例 如果你的類屬性被分配給一個 匿名函數 你將無法直接調用它。因為訪問 class 類屬性的優先級要更高，在此場景下需要用括號括起來使用。\n\u0026lt;?php class Foo { public $bar; public function __construct() { $this-\u0026gt;bar = function() { return 10; }; } } $obj = new Foo(); echo ($obj-\u0026gt;bar)(), PHP_EOL; // 10 extends 繼承 一個類可以在聲明中用 extends 關鍵字繼承另一個類的方法和屬性。 PHP 不支持多重繼承，一個類只能繼承一個基類。\n被繼承的方法和屬性可以通過用同樣的名字重新聲明被覆蓋。但是如果父類定義方法時使用了 final 關鍵字，則該方法不可被覆蓋。可以通過 parent:: 來訪問被覆蓋的方法或屬性\n6. 簡單的類繼承範例 \u0026lt;?php class ExtendClass extends SimpleClass { // 同樣名稱的方法，將會覆蓋父類的方法  function displayVar() { echo \u0026#34;Extending class\\n\u0026#34;; parent::displayVar(); } } $extended = new ExtendClass(); $extended-\u0026gt;displayVar(); // outputs // Extending class // a default value ?\u0026gt; 簽名兼容性規則 當覆蓋（override）方法時，簽名必須兼容父類方法。否則會導致 Fatal 錯誤（PHP 8.0.0 之前是 E_WARNING 級錯誤）。兼容簽名是指：遵守協變與逆變規則； 強制參數可以改為可選參數；新參數為可選參數。這就是著名的里氏替換原則（Liskov Substitution Principle），簡稱 LSP。不過構造器和 私有（private）方法不需要遵循簽名兼容規則， 哪怕簽名不匹配也不會導致 Fatal(致命) 錯誤\n7. 兼容子類方法 \u0026lt;?php class Base { public function foo(int $a) { echo \u0026#34;Valid\\n\u0026#34;; } } class Extend1 extends Base { function foo(int $a = 5) // 新參數為可選參數  { parent::foo($a); } } class Extend2 extends Base { function foo(int $a, $b = 5) { parent::foo($a); } } $extended1 = new Extend1(); $extended1-\u0026gt;foo(); $extended2 = new Extend2(); $extended2-\u0026gt;foo(1); // 輸出 // Valid // Valid 8.子類方法移除參數后，導致 Fatal(致命) 錯誤 演示子類與父類方法不兼容的例子：通過移除參數、修改可選參數為必填參數。\n\u0026lt;?php class Base { public function foo(int $a = 5) { echo \u0026#34;Valid\\n\u0026#34;; } } class Extend extends Base { function foo() { parent::foo(1); } } // 聲明必須與Base class 的foo方法兼容 //Fatal error: Declaration of Extend::foo() must be compatible with Base::foo(int $a = 5) ::class 關鍵詞 class 也可用於類名的解析。使用 ClassName::class 可以獲取包含類 ClassName 的完全限定名稱。這對使用了 命名空間 的類尤其有用。\n9. 類名的解析 \u0026lt;?php namespace NS { class ClassName { } echo ClassName::class; } ?\u0026gt; // 輸出 // NS\\ClassName :::warning 使用 ::class 解析類名操作會在底層編譯時進行。這意味著在執行該操作時，類還沒有被加載。因此，即使要調用的類不存在，類名也會被展示。在此種場景下，並不會發生錯誤。\n10. 解析不存在的類名 \u0026lt;?php print Does\\Not\\Exist::class; ?\u0026gt; 輸出: Does\\Not\\Exist :::\n11. 類名解析 自 PHP 8.0.0 起，與上述情況不同，此時解析將會在運行時進行。此操作的運行結果和 get_class() 函數一致\n\u0026lt;?php namespace NS { class ClassName { } } $c = new ClassName(); print $c::class; ?\u0026gt; // 輸出 // NS\\ClassName Nullsafe 方法和屬性 自 PHP 8.0.0 起，類屬性和方法可以通過\u0026quot;nullsafe\u0026rdquo; 操作符訪問：除了一處不同，nullsafe 操作符和以上原來的屬性、方法訪問是一致的： 對象引用解析（dereference）為 並且如果是鍊式調用中的一部分，剩餘鏈條會直接跳過。?-\u0026gt;nullnull\n此操作的結果，類似於在每次訪問前使用\n12. Nullsafe 操作符 \u0026lt;?php // 自 PHP 8.0.0 起可用 $result = $repository?-\u0026gt;getUser(5)?-\u0026gt;name; // 上面的code和下面相同 if (is_null($repository)) { $result = null; } else { $user = $repository-\u0026gt;getUser(5); if (is_null($user)) { $result = null; } else { $result = $user-\u0026gt;name; } } ?\u0026gt; :::warning 注意\n僅當 null 被認為是屬性或方法返回的有效和預期的可能值時，才推薦使用 nullsafe 操作符。如果業務中需要明確指示錯誤，拋出異常會是更好的處理方式。 :::\n class 屬性 類的變量成員叫做“屬性”，或者叫“字段”、“特徵”，在 PHP 文檔統一稱為“屬性”。屬性聲明是由關鍵字 public(公開)，protected(非公開) 或者 private(私有) 開頭，然後跟一個普通的變量聲明來組成。屬性中的變量可以初始化，但是初始化的值必須是常數，這裡的常數是指 PHP 腳本在編譯階段時就可以得到其值，而不依賴於運行時的信息才能求值。\n在類的成員方法裡面，可以用 -\u0026gt;（對象運算符）：$this-\u0026gt;property（其中 property 是該屬性名）這種方式來訪問非靜態屬性。\n靜態屬性則是用 ::（雙冒號）：self::$property 來訪問。\n以下為屬性聲明範例\n\u0026lt;?php class SimpleClass { // 錯誤的屬性聲明  public $var1 = \u0026#39;hello \u0026#39; . \u0026#39;world\u0026#39;; public $var2 = \u0026lt;\u0026lt;\u0026lt;EODhello world EOD; public $var3 = 1+2; public $var4 = self::myStaticMethod(); public $var5 = $myVar; // 正確的屬性聲明  public $var6 = myConstant; public $var7 = array(true, false); //在 PHP 5.3.0 及之後，下面的聲明也正確  public $var8 = \u0026lt;\u0026lt;\u0026lt;\u0026#39;EOD\u0026#39; hello world EOD; } ?\u0026gt;  類常量 可以把在類中始終保持不變的值定義為常量。在定義和使用常量的時候不需要使用 $ 符號。 常量的值必須是一個定值，不能是變量，類屬性，數學運算的結果或函數調用。\n如何定義和使用類常量，查看以下範例\n\u0026lt;?php class MyClass { const constant = \u0026#39;constant value\u0026#39;; function showConstant() { echo self::constant . \u0026#34;\\n\u0026#34;; } } echo MyClass::constant . \u0026#34;\\n\u0026#34;; $classname = \u0026#34;MyClass\u0026#34;; echo $classname::constant . \u0026#34;\\n\u0026#34;; // 自 5.3.0 起  $class = new MyClass(); $class-\u0026gt;showConstant(); echo $class::constant.\u0026#34;\\n\u0026#34;; // 自 PHP 5.3.0 起 ?\u0026gt;  類的自動加載 在編寫有關於對象（OOP） 程序時，很多開發者為每個類新建一個 PHP 文件。這會帶來一個煩惱：每個腳本的開頭，都需要包含（include）一個長長的列表（每個類都有個文件）。\n在 PHP 5 中，已經不再需要這樣了。 spl_autoload_register() 函數可以註冊任意數量的自動加載器，當使用尚未被定義的類（class）和接口（interface）時自動去加載。通過註冊自動加載器，腳本引擎在 PHP 出錯失敗前有了最後一個機會加載所需的類。\n:::info 儘管 **autoload() 函數也能自動加載類和接口，但更建議使用 spl_autoload_register() 函數。 spl_autoload_register() 提供了一種更加靈活的方式來實現類的自動加載（同一個應用中，可以支持任意數量的加載器，比如第三方庫中的）。因此，不再建議使用 **autoload() 函數，在以後的版本中它可能被棄用 :::\n1. 自動加載範例 本例嘗試分別從 MyClass1.php 和 MyClass2.php 文件中加載 MyClass1 和 MyClass2 類。\n\u0026lt;?php spl_autoload_register(function ($class_name) { require_once $class_name . \u0026#39;.php\u0026#39;; }); $obj = new MyClass1(); $obj2 = new MyClass2(); ?\u0026gt; 2. 自動加載在 PHP 5.3.0+ 中的異常處理 \u0026lt;?php spl_autoload_register(function ($name) { echo \u0026#34;Want to load $name.\\n\u0026#34;; throw new Exception(\u0026#34;Unable to load $name.\u0026#34;); }); try { $obj = new NonLoadableClass(); } catch (Exception $e) { echo $e-\u0026gt;getMessage(), \u0026#34;\\n\u0026#34;; } ?\u0026gt; // Want to load NonLoadableClass. // Unable to load NonLoadableClass. 構造函數和析構函數 構造函數 __construct(mixed ...$values = \u0026quot;\u0026quot;): void\nPHP 允許開發者在一個類中定義一個方法作為構造函數。具有構造函數的類會在每次創建新對象時先調用此方法，所以非常適合在使用對象之前做一些初始化工作\n:::warning 注意: 如果子類中定義了構造函數則不會隱式調用其父類的構造函數。要執行父類的構造函數，需要在子類的構造函數中調用 parent::__construct()。如果子類沒有定義構造函數則會如同一個普通的類方法一樣從父類繼承（假如沒有被定義為 private 的話）。 :::\n1. 繼承中的構造函數 \u0026lt;?php class BaseClass { function __construct() { print \u0026#34;In BaseClass constructor\\n\u0026#34;; } } class SubClass extends BaseClass { function __construct() { parent::__construct(); print \u0026#34;In SubClass constructor\\n\u0026#34;; } } class OtherSubClass extends BaseClass { // 繼承 BaseClass 的構造函數 } // In BaseClass constructor $obj = new BaseClass(); // In BaseClass constructor // In SubClass constructor $obj = new SubClass(); // In BaseClass constructor $obj = new OtherSubClass(); ?\u0026gt; 2. 構造器函數 因此可以定義任何數量的參數，可以是必選、可以有類型、可以有默認值。構造器的參數放在類名後的括號裡調用。\n\u0026lt;?php class Point { protected int $x; protected int $y; public function __construct(int $x, int $y = 0) { $this-\u0026gt;x = $x; $this-\u0026gt;y = $y; } } // 兩個參數都傳入 $p1 = new Point(4, 5); // 僅傳入必填的參數。 $y 會默認為0。 $p2 = new Point(4); // 使用命名參數（PHP 8.0 起）: $p3 = new Point(y: 5, x: 4); ?\u0026gt; 如果一個類沒有構造函數，以及構造函數的參數不是必填項時，括號就可以省略。\n析構函數 __destruct(): void\n1. 析構函數範例 \u0026lt;?php class MyDestructableClass { function __construct() { print \u0026#34;In constructor\\n\u0026#34;; } function __destruct() { print \u0026#34;Destroying \u0026#34; . __CLASS__ . \u0026#34;\\n\u0026#34;; } } $obj = new MyDestructableClass(); 和構造函數一樣，父類的析構函數不會被引擎暗中調用。要執行父類的析構函數，必須在子類的析構函數體中顯式調用 parent::__destruct()。\n此外也和構造函數一樣，子類如果自己沒有定義析構函數則會繼承父類的。 析構函數即使在使用 exit() 終止腳本運行時也會被調用。\n在析構函數中調用 exit() 將會中止其餘關閉操作的運行。\n:::warning 注意: 析構函數在腳本關閉時調用，此時所有的 HTTP 頭信息已經發出。腳本關閉時的工作目錄有可能和在 SAPI（如 apache）中時不同 :::\n:::warning 注意: 試圖在析構函數（在腳本終止時被調用）中拋出一個異常會導致致命錯誤。 :::\n 訪問控制(可見性) 對屬性或方法的訪問控制（PHP 7.1.0 以後支持常量），通過在前面添加關鍵字 public（公有），protected（受保護）或 private（私有）來實現的。\n被定義為公有的類成員可以在任何地方被訪問。被定義為受保護的類成員則可以被其自身以及其子類和父類訪問。被定義為私有的類成員則只能被其定義所在的類訪問。\n屬性的訪問控制 1. 屬性聲明 類屬性必須定義為公有，受保護，私有之一。如果用 var 定義，則被視為公有\n\u0026lt;?php /** * Define MyClass */ class MyClass { public $public = \u0026#39;Public\u0026#39;; protected $protected = \u0026#39;Protected\u0026#39;; private $private = \u0026#39;Private\u0026#39;; function printHello() { echo $this-\u0026gt;public; echo $this-\u0026gt;protected; echo $this-\u0026gt;private; } } $obj = new MyClass(); echo $obj-\u0026gt;public; // 這行能被正常執行 echo $obj-\u0026gt;protected; // 這行會產生一個致命錯誤 echo $obj-\u0026gt;private; // 這行也會產生一個致命錯誤 $obj-\u0026gt;printHello(); // 輸出 Public、Protected 和 Private  /** * Define MyClass2 */ class MyClass2 extends MyClass { // 可以對 public 和 protected 進行重定義，但 private 而不能  public $public = \u0026#39;Public2\u0026#39;; protected $protected = \u0026#39;Protected2\u0026#39;; function printHello() { echo $this-\u0026gt;public; echo $this-\u0026gt;protected; echo $this-\u0026gt;private; } } $obj2 = new MyClass2(); echo $obj2-\u0026gt;public; // 這行能被正常執行 echo $obj2-\u0026gt;protected; // 這行會產生一個致命錯誤 echo $obj2-\u0026gt;private; // 未定義 private $obj2-\u0026gt;printHello(); // 輸出 Public2、Protected2 和 Undefined  ?\u0026gt; 方法的訪問控制 方法聲明 \u0026lt;?php /** * Define MyClass */ class MyClass { // 聲明一個公有的構造函數  public function __construct() { } // 聲明一個公有的方法  public function MyPublic() { } // 聲明一個受保護的方法  protected function MyProtected() { } // 聲明一個私有的方法  private function MyPrivate() { } // 預設為公開方法  function Foo() { $this-\u0026gt;MyPublic(); $this-\u0026gt;MyProtected(); $this-\u0026gt;MyPrivate(); } } $myclass = new MyClass; $myclass-\u0026gt;MyPublic(); // 這行能被正常執行 $myclass-\u0026gt;MyProtected(); // 會出現致命錯誤 $myclass-\u0026gt;MyPrivate(); // 會出現致命錯誤 $myclass-\u0026gt;Foo(); // 公有，受保護，私有都可以執行  /** * Define MyClass2 */ class MyClass2 extends MyClass { // 為公開的函數  function Foo2() { $this-\u0026gt;MyPublic(); $this-\u0026gt;MyProtected(); $this-\u0026gt;MyPrivate(); // 會發生錯誤  } } $myclass2 = new MyClass2; $myclass2-\u0026gt;MyPublic(); // 这行能被正常执行 $myclass2-\u0026gt;Foo2(); // 公有，受保護，私有不可執行只能在原class裡執行  class Bar { public function test() { $this-\u0026gt;testPrivate(); $this-\u0026gt;testPublic(); } public function testPublic() { echo \u0026#34;Bar::testPublic\\n\u0026#34;; } private function testPrivate() { echo \u0026#34;Bar::testPrivate\\n\u0026#34;; } } class Foo extends Bar { public function testPublic() { echo \u0026#34;Foo::testPublic\\n\u0026#34;; } private function testPrivate() { echo \u0026#34;Foo::testPrivate\\n\u0026#34;; } } $myFoo = new foo(); $myFoo-\u0026gt;test(); // Bar::testPrivate  // Foo::testPublic ?\u0026gt; 常量的控制訪問 php 7.1 up 中常量聲明 \u0026lt;?php /** * Define MyClass */ class MyClass { // 公有常量  public const MY_PUBLIC = \u0026#39;public\u0026#39;; // 受保護的常量  protected const MY_PROTECTED = \u0026#39;protected\u0026#39;; // 私有常量  private const MY_PRIVATE = \u0026#39;private\u0026#39;; public function foo() { echo self::MY_PUBLIC; echo self::MY_PROTECTED; echo self::MY_PRIVATE; } } $myclass = new MyClass(); MyClass::MY_PUBLIC; // 這行可以正常執行 MyClass::MY_PROTECTED; // 這行會產生一個致命錯誤 MyClass::MY_PRIVATE; // 這行會產生一個致命錯誤 $myclass-\u0026gt;foo(); // 將會輸出：Public Protected Private  /** * Define MyClass2 */ class MyClass2 extends MyClass { // This is public  function foo2() { echo self::MY_PUBLIC; echo self::MY_PROTECTED; echo self::MY_PRIVATE; // 這行會產生一個致命錯誤  } } $myclass2 = new MyClass2; echo MyClass2::MY_PUBLIC; // 這行可以正常執行 $myclass2-\u0026gt;foo2(); // 將會輸出：Public Protected，MY_PRIVATE 是私有常量，無法輸出 ?\u0026gt; 其他對象的訪問控制 訪問同一個對像類型的私有成員 同一個類的對象即使不是同一個實例也可以互相訪問對方的私有與受保護成員。這是由於在這些對象的內部具體實現的細節都是已知的\n\u0026lt;?php class Test { private $foo; public function __construct($foo) { $this-\u0026gt;foo = $foo; } private function bar() { echo \u0026#39;Accessed the private method.\u0026#39;; } public function baz(Test $other) { // We can change the private property:  $other-\u0026gt;foo = \u0026#39;hello\u0026#39;; var_dump($other-\u0026gt;foo); // We can also call the private method:  $other-\u0026gt;bar(); } } $test = new Test(\u0026#39;test\u0026#39;); $test-\u0026gt;baz(new Test(\u0026#39;other\u0026#39;)); ?\u0026gt; // outputs // string(5) \u0026#34;hello\u0026#34; // Accessed the private method. 範圍解析操作符(::) php 可以利用這一對冒號來訪問靜態成員，類常量，還可以用於覆蓋類中的屬性和方法\n在類的外部使用 :: 操作符 \u0026lt;?php class MyClass { const CONST_VALUE = \u0026#39;A constant value\u0026#39;; } $classname = \u0026#39;MyClass\u0026#39;; echo $classname::CONST_VALUE; // 自 PHP 5.3.0 起  echo MyClass::CONST_VALUE; ?\u0026gt; self，parent 和 static 這三個特殊的關鍵字是用於在類定義的內部對其屬性或方法進行訪問的。\n在類定義內部使用 :: \u0026lt;?php class OtherClass extends MyClass { public static $my_static = \u0026#39;static var\u0026#39;; public static function doubleColon() { echo parent::CONST_VALUE . \u0026#34;\\n\u0026#34;; echo self::$my_static . \u0026#34;\\n\u0026#34;; } } $classname = \u0026#39;OtherClass\u0026#39;; echo $classname::doubleColon(); // 自 PHP 5.3.0 起  OtherClass::doubleColon(); ?\u0026gt; 當一個子類覆蓋其父類中的方法時，PHP 不會調用父類中已被覆蓋的方法。是否調用父類的方法取決於子類。這種機制也作用於構造函數和析構函數，重載以及魔術方法。\n調用父類的方法 \u0026lt;?php class MyClass { protected function myFunc() { echo \u0026#34;MyClass::myFunc()\\n\u0026#34;; } } class OtherClass extends MyClass { // 覆蓋了父類定義  public function myFunc() { // 但還是可以調用父類中被覆盖的方法  parent::myFunc(); echo \u0026#34;OtherClass::myFunc()\\n\u0026#34;; } } $class = new OtherClass(); $class-\u0026gt;myFunc(); ?\u0026gt; 靜態(static)關鍵字 聲明類屬性或方法為靜態，就可以不實例化類而直接訪問。靜態屬性不能通過一個類已實例化的對象來訪問（但靜態方法可以）\n靜態方法 靜態方法示例 \u0026lt;?php class Foo { public static function aStaticMethod() { // ...  } } Foo::aStaticMethod(); $classname = \u0026#39;Foo\u0026#39;; $classname::aStaticMethod(); ?\u0026gt; 靜態屬性 靜態屬性不可以由對象通過 -\u0026gt; 操作符來訪問。 就像其它所有的 PHP 靜態變量一樣，靜態屬性在初始化時遵循和 const 表達式一樣的規則： 有一些特定的表達式是可行的，取決於它們是否能在編譯時就計算出值。 通過變量來引用一個類是可行的，但這個變量的值不能是一個保留字 （例如 self，parent 和 static）\n\u0026lt;?php class Foo { public static $my_static = \u0026#39;foo\u0026#39;; public function staticValue() { return self::$my_static; } } class Bar extends Foo { public function fooStatic() { return parent::$my_static; } } print Foo::$my_static . \u0026#34;\\n\u0026#34;; $foo = new Foo(); print $foo-\u0026gt;staticValue() . \u0026#34;\\n\u0026#34;; print $foo-\u0026gt;my_static . \u0026#34;\\n\u0026#34;; // 未定義的 \u0026#34;屬性\u0026#34; my_static  print $foo::$my_static . \u0026#34;\\n\u0026#34;; $classname = \u0026#39;Foo\u0026#39;; print $classname::$my_static . \u0026#34;\\n\u0026#34;; print Bar::$my_static . \u0026#34;\\n\u0026#34;; $bar = new Bar(); print $bar-\u0026gt;fooStatic() . \u0026#34;\\n\u0026#34;; ?\u0026gt; 抽象類 PHP 也支援抽象類的和抽象方法，被定義為抽象類的方法不能被實體化，在任何一個類別中， 如果他至少有一個方法被聲明為抽象，那這個類必須要被聲明為抽象類。被定義為抽象類的方法只能聲明他該怎麼使用，不能定義具體功能實現。\n當有類別繼承抽象類別時，子類別必須要定義父類別中的所以抽象方法，另外，這些方法的訪問控制必須和父類中一樣（或者更為寬鬆）。例如某個抽象方法是被聲明為受保護的，那麼子類中實現的方法就應該聲明為受保護的或者公有的，而不能定義為私有的。\n此外方法的調用方式必須匹配，即類型和所需參數數量必須一致。例如，子類定義了一個可選參數，而父類抽象方法的聲明里沒有，則兩者的聲明並無衝突。\n 這也適用於 PHP 5.4 起的構造函數。在 PHP 5.4 之前的構造函數聲明可以不一樣的。\n 1. 抽象類範例 1 \u0026lt;?php abstract class AbstractClass { // 子類必須定義這些方法，否則會出錯  abstract protected function getValue(); abstract protected function prefixValue($prefix); // 普通方法（非抽象方法）  public function printOut() { print $this-\u0026gt;getValue() . \u0026#34;\\n\u0026#34;; } } class ConcreteClass1 extends AbstractClass { protected function getValue() { return \u0026#34;ConcreteClass1\u0026#34;; } public function prefixValue($prefix) { return \u0026#34;{$prefix}ConcreteClass1\u0026#34;; } } class ConcreteClass2 extends AbstractClass { public function getValue() { return \u0026#34;ConcreteClass2\u0026#34;; } public function prefixValue($prefix) { return \u0026#34;{$prefix}ConcreteClass2\u0026#34;; } } $class1 = new ConcreteClass1; $class1-\u0026gt;printOut(); echo $class1-\u0026gt;prefixValue(\u0026#39;FOO_\u0026#39;) .\u0026#34;\\n\u0026#34;; $class2 = new ConcreteClass2; $class2-\u0026gt;printOut(); echo $class2-\u0026gt;prefixValue(\u0026#39;FOO_\u0026#39;) .\u0026#34;\\n\u0026#34;; ?\u0026gt; // outputs // ConcreteClass1 // FOO_ConcreteClass1 // ConcreteClass2 // FOO_ConcreteClass2 2. 抽象類範例 2 \u0026lt;?php abstract class AbstractClass { // 我们的抽象方法仅需要定义需要的参数  abstract protected function prefixName($name); } class ConcreteClass extends AbstractClass { // 子類的方法可以定義父類方法中不存在的可選參數，不衝突  public function prefixName($name, $separator = \u0026#34;.\u0026#34;) { if ($name == \u0026#34;Pacman\u0026#34;) { $prefix = \u0026#34;Mr\u0026#34;; } elseif ($name == \u0026#34;Pacwoman\u0026#34;) { $prefix = \u0026#34;Mrs\u0026#34;; } else { $prefix = \u0026#34;\u0026#34;; } return \u0026#34;{$prefix}{$separator}{$name}\u0026#34;; } } $class = new ConcreteClass; echo $class-\u0026gt;prefixName(\u0026#34;Pacman\u0026#34;), \u0026#34;\\n\u0026#34;; echo $class-\u0026gt;prefixName(\u0026#34;Pacwoman\u0026#34;), \u0026#34;\\n\u0026#34;; ?\u0026gt; // outputs // Mr. Pacman // Mrs. Pacwoman Interface 對象接口也稱介面 使用介面（interface），可以指定某個類必須實現哪些方法，但不需要定義這些方法的具體內容。由於介面（interface）和類（class）、trait 共享了命名空間，所以它們不能重名。介面就像定義一個標準的類一樣，通過 interface 關鍵字替換掉 class 關鍵字來定義，但其中所有的方法都是空的。介面中定義的所有方法都必須是公有，這是介面的特性。在實踐中，往往出於兩個輔助目的使用介面： 因為實現了同一個介面，所以開發者創建的對象雖然源自不同的類，但可能可以交換使用。常用於多個數據庫的服務訪問、多個支付網關、不同的緩存策略等。可能不需要任何代碼修改，就能切換不同的實現方式。能夠讓函數與方法接受一個符合介面的參數，而不需要關心對像如何做、如何實現。這些介面常常命名成類似 Iterable、Cacheable、Renderable， 以便於體現出功能的含義。\n:::warning 注意: 雖然沒有禁止，但是強烈建議不要在接口中使用 構造器。因為這樣在對象實現接口時，會大幅降低靈活性。此外，也不能強制確保構造器遵守繼承規則，將導致不可預料的行為結果。 :::\n實現 implements 要使用一個介面，使用 implements 操作符。類中必須使用介面中定義的所有方法，否則會報一個致命錯誤。類可以實現多個接口，用逗號來分隔多個接口的名稱。\n:::danger 警告：類使用（implement）兩個接口時，如果它們定義了相同名稱的方法，只有簽名相同的時候才是允許的。 :::\n:::danger 警告：使用介面的時候，class 中的參數名稱不必和介面完全一致。然而， PHP 8.0 起語法開始支持命名參數， 也就是說調用方會依賴介面中參數的名稱。因此，強烈建議開發者的參數的命名，在類和介面中保持一致。 :::\n:::warning 注意:接口也可以通過 extends 操作符繼承 :::\n:::warning 注意:類實現介面時，必須以兼容的簽名定義介面中所有方法。 :::\n1. 介面範例 \u0026lt;?php // 聲明一個\u0026#39;Template\u0026#39;介面 interface Template { public function setVariable($name, $var); public function getHtml($template); } // 使用介面 // 正確寫法如下 class WorkingTemplate implements Template { private $vars = []; public function setVariable($name, $var) { $this-\u0026gt;vars[$name] = $var; } public function getHtml($template) { foreach($this-\u0026gt;vars as $name =\u0026gt; $value) { $template = str_replace(\u0026#39;{\u0026#39; . $name . \u0026#39;}\u0026#39;, $value, $template); } return $template; } } // 下面的寫法是錯誤的，會報錯，因為沒有使用到該介面方法 getHtml()： // Fatal error: Class BadTemplate contains 1 abstract methods // and must therefore be declared abstract (Template::getHtml) class BadTemplate implements Template { private $vars = []; public function setVariable($name, $var) { $this-\u0026gt;vars[$name] = $var; } } ?\u0026gt; 2. 可擴充介面 \u0026lt;?php interface A { public function foo(); } interface B extends A { public function baz(Baz $baz); } // 正確寫法 class C implements B { public function foo() { } public function baz(Baz $baz) { } } // 錯誤寫法導致致命錯誤 class D implements B { public function foo() { } public function baz(Foo $foo) // 參考錯誤  { } } ?\u0026gt; 3. 拓展多介面 \u0026lt;?php interface A { public function foo(); } interface B { public function bar(); } interface C extends A, B { public function baz(); } class D implements C { public function foo() { } public function bar() { } public function baz() { } } ?\u0026gt; 4. 使用介面常量 \u0026lt;?php interface A { const B = \u0026#39;Interface constant\u0026#39;; } // 输出接口常量 echo A::B; // 錯誤寫法，因為常量不能被覆蓋。接口常量的概念和類常量是一樣的。 class B implements A { const B = \u0026#39;Class constant\u0026#39;; } ?\u0026gt; 5. 抽象（abstract）類的介面使用 \u0026lt;?php interface A { public function foo(string $s): string; public function bar(int $i): int; } // 抽象類可能僅實現了接口的一部分。 // 擴展該抽象類時必須實現剩餘部分 abstract class B implements A { pubic function foo(string $s): string { return $s . PHP_EOL; } } class C extends B { public function bar(int $i): int { return $i * 2; } } ?\u0026gt; 6. 同時使用繼承和介面 \u0026lt;?php class One { /* ... */ } interface Usable { /* ... */ } interface Updatable { /* ... */ } // 關鍵字順序至關重要： \u0026#39;extends\u0026#39; 必須在前面 class Two extends One implements Usable, Updatable { /* ... */ } ?\u0026gt; 資料來源: https://www.php.net/\n","permalink":"https://joe94113.github.io/blog/php_learn/","tags":["Backend"],"title":"PHP學習筆記(持續更新中)"},{"categories":["Javascript"],"contents":"Html select 選單設定\u0026rsquo;disabled\u0026rsquo; =\u0026gt; \u0026lsquo;true'無法 submit 解法 設定成\u0026rsquo;disabled\u0026rsquo; =\u0026gt; \u0026lsquo;true'代表不能更改，但在傳送表單時無法傳遞出去\n可以使用 Jquery 解法，在表單 submit 時將 disabled 設成 false\njQuery(function ($) { $(\u0026#34;form\u0026#34;).bind(\u0026#34;submit\u0026#34;, function () { $(this).find(\u0026#34;:input\u0026#34;).prop(\u0026#34;disabled\u0026#34;, false); }); }); ","permalink":"https://joe94113.github.io/blog/html_select_can_not_submit/","tags":["Frontend"],"title":"Html select選單設定'disabled' =\u003e 'true'無法submit解法"},{"categories":["Javascript"],"contents":"JS 實現部分區域全螢幕即退出 1. 首先找出要全螢幕區域 `var elem = document.getElementById(\u0026quot;game\u0026quot;);`  2. 建立全螢幕 function // 局部全螢幕 function requestFullScreen(element) { var requestMethod = element.requestFullScreen || element.webkitRequestFullScreen || element.mozRequestFullScreen || element.msRequestFullScreen; if (requestMethod) { requestMethod.call(element); } else if (typeof window.ActiveXObject !== \u0026#34;undefined\u0026#34;) { var wscript = new ActiveXObject(\u0026#34;WScript.Shell\u0026#34;); if (wscript !== null) { wscript.SendKeys(\u0026#34;{F11}\u0026#34;); } } } 3. 將選到 element 區塊全螢幕 `requestFullScreen(elem);`  4. 退出全螢幕函數 function exitFullscreen() { if (document.exitFullscreen) { document.exitFullscreen(); } else if (document.msExitFullscreen) { document.msExitFullscreen(); } else if (document.mozCancelFullScreen) { document.mozCancelFullScreen(); } else if (document.webkitExitFullscreen) { document.webkitExitFullscreen(); } } 5. 監聽按鈕事件 我是設置一個是否為全螢幕的變數去跑，這樣就只需要一個按鈕就可以解決\nvar btn = document.getElementById(\u0026quot;btn\u0026quot;); // 尋找button id=btn的按鈕 btn.onclick = function () { // 監聽btn按鈕click事件 var elem = document.getElementById(\u0026quot;content\u0026quot;); // 要全螢幕的element id requestFullScreen(elem); // 全螢幕 }; var close = document.getElementById(\u0026quot;close\u0026quot;); // 尋找button id=close的按鈕 close.onclick = function () { // 監聽close按鈕click事件 exitFullscreen(); // 關閉全螢幕 }; --- // 以下由一個button完成 var fullscreen = false; var btn = document.getElementById(\u0026quot;btn\u0026quot;); var elem = document.getElementById(\u0026quot;content\u0026quot;); btn.onclick = function () { if(fullscreen){ exitFullscreen(); fullscreen = false; }else{ requestFullScreen(elem); fullscreen = true; } }; ","permalink":"https://joe94113.github.io/blog/js_screen/","tags":["Frontend"],"title":"JS實現部分區域全螢幕即退出"},{"categories":["Laravel"],"contents":"Laravel 路由 基本路由 首先看到 rotues 資料夾裡的 web.php，會看到這些程式碼\nRoute::get('/', function () { // 使用get方法請求 return view('welcome'); // 回傳view給他 }); view 的位置就放在resources\\views\\welcome.blade.php\n接下來說說來說說基本路由 Laravel 的路由只接受一個 URI 和一個 Closure(閉包)\nRoute::get(\u0026#39;foo\u0026#39;, function () { return \u0026#39;Hello World\u0026#39;; }); laravel 可以使用所有 HTTP 的方法\nRoute::get($uri, $callback); Route::post($uri, $callback); Route::put($uri, $callback); Route::patch($uri, $callback); Route::delete($uri, $callback); Route::options($uri, $callback); 可能你這個路由可以響應多個 HTTP 的請求，可以使用 match，或者任何請求都可以就使用 any\nRoute::match([\u0026#39;get\u0026#39;, \u0026#39;post\u0026#39;], \u0026#39;/\u0026#39;, function () { // }); Route::any(\u0026#39;foo\u0026#39;, function () { // }); 如果有將路由指向任何 HTML 表單 POST，PUT 或 DELETE 放在web.php中，應當包括 CSRF 令牌字段。否則，請求將被拒絕。\n\u0026lt;form method=\u0026#34;POST\u0026#34; action=\u0026#34;/profile\u0026#34;\u0026gt;{{ csrf_field() }} ...\u0026lt;/form\u0026gt; 路由參數 所需參數 有時需要捕捉路由中的 URI 字段，可以通過以下方式實現\nRoute::get(\u0026#39;user/{id}\u0026#39;, function ($id) { return \u0026#34;User: $id\u0026#34;; }); 如下圖所示: 可以根據自己的想法來定義更多的路線參數\nRoute::get(\u0026#39;posts/{post}/comments/{comment}\u0026#39;, function ($postId, $commentId) { // }); 可選參數 有時可能需要指定一個路由參數，但將該路由參數的存在設為可選。您可以通過?在參數名稱後放置一個標記來實現。確保給路由對應的變量一個默認值：\nRoute::get(\u0026#39;user/{name?}\u0026#39;, function ($name = null) { return $name; }); Route::get(\u0026#39;user/{name?}\u0026#39;, function ($name = \u0026#39;John\u0026#39;) { return $name; }); 正規表達法約束 您可以使用 where 路由實例上的方法來限制路由參數的格式。該 where 方法接受參數的名稱和定義參數應如何約束的正則表達式：\nRoute::get(\u0026#39;user/{name}\u0026#39;, function ($name) { // })-\u0026gt;where(\u0026#39;name\u0026#39;, \u0026#39;[A-Za-z]+\u0026#39;); // 他就會找出$name這個參數，符合規則的字段 Route::get(\u0026#39;user/{id}\u0026#39;, function ($id) { // })-\u0026gt;where(\u0026#39;id\u0026#39;, \u0026#39;[0-9]+\u0026#39;); Route::get(\u0026#39;user/{id}/{name}\u0026#39;, function ($id, $name) { // })-\u0026gt;where([\u0026#39;id\u0026#39; =\u0026gt; \u0026#39;[0-9]+\u0026#39;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;[a-z]+\u0026#39;]); 全局約束 如果您希望路由參數始終受給定正則表達式的約束，則可以使用該 pattern 方法。您應該在boot您的方法中定義這些模式RouteServiceProvider：\n/** * Define your route model bindings, pattern filters, etc. * * @return void */ public function boot() { Route::pattern(\u0026#39;id\u0026#39;, \u0026#39;[0-9]+\u0026#39;); parent::boot(); } 一旦定義了模式，它就會自動應用於使用該參數名稱的所有路由：\nRoute::get(\u0026#39;user/{id}\u0026#39;, function ($id) { // Only executed if {id} is numeric... }); 命名路由 命名路由允許為特定路由方便地生成 URL 或重定向。您可以通過將 name 方法鏈接到路由定義來為路由指定名稱：\nRoute::get(\u0026#39;user/profile\u0026#39;, function () { // })-\u0026gt;name(\u0026#39;profile\u0026#39;); 您還可以為控制器操作指定路由名稱：\nRoute::get(\u0026#39;user/profile\u0026#39;, \u0026#39;UserController@showProfile\u0026#39;)-\u0026gt;name(\u0026#39;profile\u0026#39;); 生成命名路由的 URL\n為給定路由指定名稱後，您可以在通過全局 route 函數生成 URL 或重定向時使用該路由的名稱：\n// Generating URLs... $url = route(\u0026#39;profile\u0026#39;); // Generating Redirects... return redirect()-\u0026gt;route(\u0026#39;profile\u0026#39;); 如果命名路由定義了參數，您可以將參數作為第二個參數傳遞給 route 函數。給定的參數將自動插入到 URL 的正確位置：\nRoute::get(\u0026#39;user/{id}/profile\u0026#39;, function ($id) { // })-\u0026gt;name(\u0026#39;profile\u0026#39;); $url = route(\u0026#39;profile\u0026#39;, [\u0026#39;id\u0026#39; =\u0026gt; 1]); ","permalink":"https://joe94113.github.io/blog/laravel_route/","tags":["Backend"],"title":"Laravel 路由"},{"categories":["Laravel"],"contents":"laravel 排程下載外部 Url 檔案，及更新進資料庫資料 如何下載外部公開 URL 首先利用 Client 套件下載外部 url 的 csv 檔案。\n本文撰寫使用抓取此網址https://od.cdc.gov.tw/acute/幼兒常規疫苗接種時間試算表.csv為範例\npublic function download() { $client = new \\GuzzleHttp\\Client(); $a = $client-\u0026gt;get(\u0026#39;https:/example/example.csv\u0026#39;, [\u0026#39;save_to\u0026#39; =\u0026gt; resource_path() . \u0026#39;/download/file.csv\u0026#39;]); return response(200); } 如何將下載檔案匯進資料庫 使用 laravel-excel 套件將下載的檔案 import 進資料庫\nlaravel-excel 安裝\n因為等等會用到先說說 laravel ORM 的 firstOrCreate 方法\n功能 : 將嘗試使用給定的列/值對定位數據庫記錄。如果在數據庫中找不到模型，則會插入一條記錄，其中包含將第一個數組參數與可選的第二個數組參數合併後的屬性\n以下為文檔範例:\nuse App\\Models\\Flight; // Retrieve flight by name or create it if it doesn\u0026#39;t exist... $flight = Flight::firstOrCreate([ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;London to Paris\u0026#39; ]); // Retrieve flight by name or create it with the name, delayed, and arrival_time attributes... $flight = Flight::firstOrCreate( [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;London to Paris\u0026#39;], [\u0026#39;delayed\u0026#39; =\u0026gt; 1, \u0026#39;arrival_time\u0026#39; =\u0026gt; \u0026#39;11:30\u0026#39;] ); 再來先創建要傳遞的類 檔案可以放在 app/imports/ExampleImport.php\n\u0026lt;?php namespace App\\Imports; use App\\Vaccination; use Illuminate\\Support\\Collection; use Maatwebsite\\Excel\\Concerns\\ToCollection; class VaccinationImport implements ToCollection { public function collection(Collection $rows) { foreach ($rows as $k =\u0026gt; $row) { if ($k \u0026lt; 1) continue; // 跳過標題  Vaccination::firstOrCreate([ //  \u0026#39;age\u0026#39; =\u0026gt; $row[0], \u0026#39;kind\u0026#39; =\u0026gt; $row[1], \u0026#39;remark\u0026#39; =\u0026gt; $row[3] ]); } } } 將 VaccinationImport 對像傳遞給 Excel::import()方法，將告訴包如何導入作為第二個參數傳遞的文件，第二個參數的文件就是上面程式碼下載下來的 csv 檔案放置位置。\n該文件應該位於您的默認文件系統磁盤中（參考資料 config/filesystems.php）。\npublic function import() { // 我沒有讓它找默認的，讓他尋找resource資料夾底下檔案 Excel::import(new VaccinationImport, resource_path(\u0026#39;/download/file.csv\u0026#39;)); } 功能合併新增排程 在 cmd 輸入以下指令，創建 command 檔案，算是一個可以自己寫命令(shell)的檔案\nphp artisan make:command DownloadCSV 接著在 DownloadCSV.php 中修改\n\u0026lt;?php namespace App\\Console\\Commands; use Illuminate\\Console\\Command; use App\\Imports\\VaccinationImport; use Maatwebsite\\Excel\\Facades\\Excel; class DownloadCSV extends Command { /** * The name and signature of the console command. * * @var string */ protected $signature = \u0026#39;download:vaccination\u0026#39;; // 定義一個命令  /** * The console command description. * * @var string */ protected $description = \u0026#39;排程自動下載資料，對比資料庫寫入\u0026#39;; // 一些介紹  /** * Create a new command instance. * * @return void */ public function __construct() { parent::__construct(); } /** * Execute the console command. * * @return int */ public function handle() // 主要程式碼  { $this-\u0026gt;download(); // 下載外部csv  $this-\u0026gt;import(); // 對比資料庫更新及新增  } public function download() { $client = new \\GuzzleHttp\\Client(); $client-\u0026gt;get(\u0026#39;https:/example/example.csv\u0026#39;, [\u0026#39;save_to\u0026#39; =\u0026gt; resource_path() . \u0026#39;/download/file.csv\u0026#39;]); return response(200); } public function import() { Excel::import(new VaccinationImport, resource_path(\u0026#39;/download/file.csv\u0026#39;)); } } 修改完成接下來到 app/Console/Kernel.php\n修改及導入命令程式碼\n\u0026lt;?php namespace App\\Console; use App\\Console\\Commands\\DownloadCSV; // 導入 use Illuminate\\Console\\Scheduling\\Schedule; use Illuminate\\Foundation\\Console\\Kernel as ConsoleKernel; class Kernel extends ConsoleKernel { /** * The Artisan commands provided by your application. * * @var array */ protected $commands = [ DownloadCSV::class ]; /** * Define the application\u0026#39;s command schedule. * * @param \\Illuminate\\Console\\Scheduling\\Schedule $schedule * @return void */ // 定義要排程的指令或流程  protected function schedule(Schedule $schedule) { // 這邊就會跑command檔案handle函式  // 設定為一個小時跑一次  $schedule-\u0026gt;command(\u0026#39;download:vaccination\u0026#39;)-\u0026gt;hourly(); } /** * Register the commands for the application. * * @return void */ protected function commands() { $this-\u0026gt;load(__DIR__.\u0026#39;/Commands\u0026#39;); require base_path(\u0026#39;routes/console.php\u0026#39;); } } 程式碼部分就算完成了，接下來就是要設定排程工作\n我是在 Linux 上面做開發，如要要讓它排程就要加入 CronJob\n在 Linux 上輸入\ncrontab -e\n按 i 編輯，輸入以下這行，它是告訴這個 package 每一分鐘 run 一次php artisan schedule:run 就是跑排程的意思。\n* * * * * cd /path-to-your-project \u0026amp;\u0026amp; php artisan schedule:run \u0026gt;\u0026gt; /dev/null 2\u0026gt;\u0026amp;1 path-to-your-project改成你的專案路徑\n輸入完畢按下 esc，然後輸入:wq 離開並儲存，跑出以下這行表示成功拉\ncrontab: installing new crontab\n參考資料 更多相關排程時間參考這裡\n更多排程相關資料請參照laravel Task Scheduling 文檔\n","permalink":"https://joe94113.github.io/blog/laravel_auto_download/","tags":["Backend"],"title":"laravel排程下載外部Url檔案，及更新進資料庫資料"},{"categories":["Laravel"],"contents":"Laravel目錄結構 先來說說各個目錄及資料夾裡面放置檔案，並沒有強制規定\n根目錄 app目錄 app資料夾都是應用程式的核心程式碼，大部分程式碼都放在這。\nBootstarp目錄 bootstrap 目錄包含的檔案用來啟動框架和設定自動載入；以及包含一個 cache 資料夾，其中內有框架對效能最佳化所產生的檔案，例如 route 和 services 的快取檔案。\nConfig目錄 config目錄底下包含所有應用程式的配置檔案。\nDatabase目錄 裡面放置資料庫遷移檔案以及填充檔案\nPulic目錄 public目錄存放著index.php，此檔案是應用程式的HTTP請求入口點。還包含了前端資源，如圖片，JavaScript和css\nResources目錄 目錄包含要使用的view，原始資源檔(LESS,SASS,CoffeeScript)以及語言檔\nRoutes目錄 這個目錄包含所有路由定義，laravel有預設三個路由檔案，web.php，api.php，console.php。\nweb.php裡面定義的路由都會被RouteServiceProvider分配到web的中介層(middleware)，因此會具備Session、CSRF 防護以及 Cookie 加密功能，如果應用程式無需提供無狀態的、RESTful 風格的 API，則所有的路由都會定義在 web.php 檔案中。\napi.php 檔案裡定義的路由都會在 RouteServiceProvider 中被指配到 api 中介層群組，具備頻率限制功能，這些路由是無狀態的，所以經由這些路由進入應用程式需要 token 進行認證，並且不能訪問 Session 狀態。\nconsole.php 檔案用於定義所有基於閉包的控制台指令，每個閉包都被繫結到一個控制台指令並且允許與指令列 IO 方法進行互動，儘管這個檔案並不定義 HTTP 路由，但是它定義了基於指令列的應用程式入口（路由）。\nStorage 目錄 storage 目錄包含編譯後的 Blade 模板、基於檔案的 session、檔案快取和其它框架生成的檔案。底下資料夾分隔成 app、framework，及 logs 目錄。app 目錄可用於儲存應用程式使用的任何檔案。framework 目錄被用於儲存框架生成的檔案及快取。最後，logs 目錄包含了應用程式的日誌檔案。\nstorage/app/public 可以用來存放使用者上傳檔案（例如個人大頭照）。為了能公開訪問，需要建立 public/storage 連結（symbolic link），然後指到 storage/app/public 這個資料夾，你可以使用 php artisan storage:link 來建立連結。\nTests 目錄 tests 目錄包含自動化測試的檔案。有預設一個現成的 PHPUnit 範例。每一個測試類都需要新增 Test 字首，你可以使用 phpunit 或者 php vendor/bin/phpunit 指令來執行測試。\nVendor 目錄 vendor 目錄包含你的 Composer 依賴模組，套件檔案都放這。\nApp 目錄 在 app 目錄中的很多類別都可以透過 Artisan 指令產生，要檢視所有有效的指令，可以在終端機中執行 php artisan list make 指令。\nConsole 目錄 Console 目錄包含應用程式所有自定義的 Artisan 指令，這些指令類別可以使用 make:command 指令產生。\nEvents 目錄 Events 目錄預設不存在，會在你使用 event:generate 或 make:event 指令以後才會被建立。此 Events 目錄是用來放置事件類別的。\nExceptions 目錄 Exceptions 目錄包含應用程式的異常處理程序，同時也是個處置應用程式丟擲異常的好位置。如果你想自定義異常的記錄和渲染，你應該修改此目錄下的 Handler 類別。\nHttp 目錄 Http 目錄包含了控制器、中介層以及表單請求等，幾乎所有進入應用程式的請求處理都放在這裡。\nJobs 目錄 該目錄預設不存在，可以通過執行 make:job 指令建立，Jobs 目錄用於存放佇列任務，應用程式中的任務可以被佇列化，也可以在當前請求生命週期內同步執行。同步執行的任務有時也被看作指令，因為它們實現了命令模式。\nListeners 目錄 這個目錄預設不存在，可以通過執行 event:generate 和 make:listener 指令建立。Listeners 目錄包含處理事件的類別（事件監聽器），事件監聽器接收一個事件並提供對該事件發生後的響應邏輯，例如，UserRegistered 事件可以被 SendWelcomeEmail 監聽器處理。\nMail 目錄 這個目錄預設不存在，但是可以通過執行 make:mail 指令產生，Mail 目錄包含郵件傳送類別，郵件物件允許你在一個地方封裝構建郵件所需的所有業務邏輯，然後使用 Mail::send 方法傳送郵件。\nNotifications 目錄 這個目錄預設不存在，可以通過執行 make:notification 指令建立， Notifications 目錄包含應用程式傳送的所有通知。\nPolicies 目錄 這個目錄預設不存在，可以通過執行 make:policy 指令來建立， Policies 目錄包含了所有的授權策略類別，策略用於判斷某個使用者是否有許可權去訪問指定資源。\nProviders 目錄 Providers 目錄包含應用程式的服務提供者。服務提供者在啟動應用程式過程中繫結服務到容器、註冊事件，以及執行其他任務，為即將到來的請求處理做準備。\n","permalink":"https://joe94113.github.io/blog/laravel_folder/","tags":["Backend"],"title":"Laravel目錄結構"},{"categories":["Laravel"],"contents":"Laravel起步走 Laravel是一個MVC架構的PHP框架，分別是model(資料處理)，controller(控制器)，view(呈現畫面)，\nLaravel還有提供了驗證(authentication)、路由(routing)、sessions、快取(caching) 等開發過程中經常用到的工具或功能。是一個強大的網頁開發框架。\n那要怎麼使用laravel呢?\n1. 安裝composer 首先先下載composer官方載點 我是window開發用戶 安裝後選擇本機php位置安裝，安裝完畢後可以在命令提示字元(簡稱cmd)確認是否安裝完成 輸入:composer -v 看到這畫面代表成功囉\n2. 下載laravel cmd輸入:composer global require laravel/installer\n3. 新增laravel專案 cmd輸入: laravel new \u0026quot;專案名稱\u0026quot; 4. 開啟laravel 首先先進入laravel專案 cmd輸入: cd \u0026quot;專案名稱\u0026quot; cmd輸入: php artisan serve 網址輸入: http://127.0.0.1:8000/ 就可以看到預設的laravel畫面囉 ","permalink":"https://joe94113.github.io/blog/laravel_start/","tags":["Backend"],"title":"Laravel起步走"},{"categories":["Linux"],"contents":"Linux遇到資料夾權限問題 問題: laravel - The stream or file \u0026quot;/storage/logs/laravel.log\u0026quot; could not be opened in append mode: failed to open stream: Permission denied\n解法: sudo chown apache:apache -R dir\nsudo chmod u+w,g+w -R dir\n","permalink":"https://joe94113.github.io/blog/linux_fix_authority/","tags":["OS"],"title":"Linux遇到資料夾權限問題"},{"categories":["Javascript"],"contents":"使用vscode Code Runner 跑JS程式碼，出現亂碼問題 問題如下圖:\n解決方法:\n安裝node.js 官方連結\n code runner套件下載連結\ncode runner\n","permalink":"https://joe94113.github.io/blog/vscode_coderunner/","tags":["vscode"],"title":"使用vscode Code Runner 跑JS程式碼，出現亂碼問題"},{"categories":["Laravel"],"contents":"解決Laravel 讀取不到.env檔案中的參數 CMD Run\ncomposer dump-autoload php artisan cache:clear php artisan config:clear php artisan view:clear ","permalink":"https://joe94113.github.io/blog/laravel_can_not_read.env/","tags":["Backend"],"title":"解決Laravel 讀取不到.env檔案中的參數"},{"categories":["Javascript"],"contents":"Jquery 網頁離開前向使用者確認 窗口的 onbeforeunload 屬性可以設置為一個函數，這個函數返回一個字符串，該字符串在對話框中顯示給用戶，以確認用戶想要離開。這是為了防止用戶端在使用過程中丟失數據。不過它經常被用來欺騙用戶。\n所以從 Chrome 51 開始，將不再向用戶顯示自定義字符串。Chrome 仍會顯示一個對話框以防止用戶丟失數據，但其內容將由瀏覽器設置而不是網頁設置。\n通過此更改，Chrome 將與 Safari 9.1 及更高版本以及 Firefox 4 及更高版本保持一致\n以下範例在大多網頁都可以執行\n$(window).on(\u0026#34;beforeunload\u0026#34;, function () { //為防止詐騙已變更為瀏覽器預設  return \u0026#34;你確定要離開嗎\u0026#34;; }); $(window).on(\u0026#34;unload\u0026#34;, function () { logout(); }); 如果有些地方不想經過確認，需要直接跳轉可以關掉\n$(window).unbind(\u0026#34;beforeunload\u0026#34;); // 關閉離開頁面提示 ","permalink":"https://joe94113.github.io/blog/js_beforeunload/","tags":["Frontend"],"title":"Jquery網頁離開前向使用者確認"},{"categories":["Laravel"],"contents":"Laravel use google map place api 輸入地址取得經緯度 註冊和啟用 PLACE API 先到 GCP 註冊，前三個月免費 到這裡搜尋 PLACE API 找到之後點選啟用 創建金鑰 點選 API 和服務-\u0026gt;點選憑證-\u0026gt;建立憑證-\u0026gt;API 金鑰 這樣子就建立成功囉\n點選限制金鑰，可以將它選擇只用來使用 place api 撰寫程式碼 創建一個 service 檔案，使用 Guzzle 來打 api\nGuzzle Docs\n\u0026lt;?php namespace App\\Http\\Services; use GuzzleHttp\\Client; class GoogleMapService { protected $client; public function __construct() { $this-\u0026gt;client = new Client(); } // 取得經緯度  public function getPlaceCoods($address) { try { $input = $address; // 輸入的地址  // 取得名稱，營業時間，評價  $inputType = \u0026#34;textquery\u0026amp;fields=formatted_address%2Cname%2Crating%2Copening_hours%2Cgeometry\u0026#34;; $api_key = env(\u0026#34;GOOGLE_PLACE_API\u0026#34;); // 將api key放到.env檔案，取出  $url = \u0026#34;https://maps.googleapis.com/maps/api/place/findplacefromtext/json?input=$input\u0026amp;inputtype=$inputType\u0026amp;key=$api_key\u0026#34;; $response = $this-\u0026gt;client-\u0026gt;request(\u0026#39;GET\u0026#39;, $url); // 打api  $contents = $response-\u0026gt;getBody()-\u0026gt;getContents(); $contents = json_decode($contents, TRUE); // 對json編碼  } catch (\\Throwable $th) { report($th); return $url; } // 判斷此地址有沒有經緯度或錯誤  if (isset($contents[\u0026#39;candidates\u0026#39;][0])) { return response()-\u0026gt;json($contents[\u0026#39;candidates\u0026#39;][0][\u0026#39;geometry\u0026#39;][\u0026#39;location\u0026#39;]); } else { return false; } } } ?\u0026gt; google place api docs\n","permalink":"https://joe94113.github.io/blog/laravel_google_place_api/","tags":["Backend"],"title":"Laravel use google map place api輸入地址取得經緯度"},{"categories":["MySQL"],"contents":"MySQ 語法 drop database \u0026#34;database名稱\u0026#34;; 創建 database\ncreate database \u0026#34;database名稱\u0026#34;; 使用這個 database\nuse \u0026#34;database名稱\u0026#34;; 基本的 CRUD 導入數據\nsource /Users/joe/Downloads/data.sql; data.sql 內容:\nCREATE TABLE employee( id INT NOT NULL AUTO_INCREMENT, first_name VARCHAR(100) NOT NULL, last_name VARCHAR(100) NOT NULL, title VARCHAR(100) DEFAULT NULL, salary DOUBLE DEFAULT NULL, hire_date DATE NOT NULL, notes TEXT, PRIMARY KEY (id) ); INSERT INTO employee (first_name, last_name, title, salary, hire_date) VALUES (\u0026#39;Robin\u0026#39;, \u0026#39;Jackman\u0026#39;, \u0026#39;Software Engineer\u0026#39;, 5500, \u0026#39;2001-10-12\u0026#39;), (\u0026#39;Taylor\u0026#39;, \u0026#39;Edward\u0026#39;, \u0026#39;Software Architect\u0026#39;, 7200, \u0026#39;2002-09-21\u0026#39;), (\u0026#39;Vivian\u0026#39;, \u0026#39;Dickens\u0026#39;, \u0026#39;Database Administrator\u0026#39;, 6000, \u0026#39;2012-08-29\u0026#39;), (\u0026#39;Harry\u0026#39;, \u0026#39;Clifford\u0026#39;, \u0026#39;Database Administrator\u0026#39;, 6800, \u0026#39;2015-12-10\u0026#39;), (\u0026#39;Eliza\u0026#39;, \u0026#39;Clifford\u0026#39;, \u0026#39;Software Engineer\u0026#39;, 4750, \u0026#39;1998-10-19\u0026#39;), (\u0026#39;Nancy\u0026#39;, \u0026#39;Newman\u0026#39;, \u0026#39;Software Engineer\u0026#39;, 5100, \u0026#39;2007-01-23\u0026#39;), (\u0026#39;Melinda\u0026#39;, \u0026#39;Clifford\u0026#39;, \u0026#39;Project Manager\u0026#39;, 8500, \u0026#39;2013-10-29\u0026#39;), (\u0026#39;Jack\u0026#39;, \u0026#39;Chan\u0026#39;, \u0026#39;Test Engineer\u0026#39;, 6500, \u0026#39;2018-09-07\u0026#39;), (\u0026#39;Harley\u0026#39;, \u0026#39;Gilbert\u0026#39;, \u0026#39;Software Architect\u0026#39;, 8000, \u0026#39;2000-07-17\u0026#39;); 查看這個 database 有哪些 table show tables +----------------+ | Tables_in_demo | +----------------+ | employee | | movie | | test | 描述 table 有哪些屬性 desc 表格名稱 desc movie; +----------------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +----------------+--------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | title | varchar(100) | NO | | NULL | | | title_year | int(11) | NO | | NULL | | | director_name | varchar(50) | NO | | NULL | | | actor_1_name | varchar(50) | NO | | NULL | | | actor_2_name | varchar(50) | NO | | NULL | | | duration | int(11) | NO | | NULL | | | country | varchar(50) | NO | | NULL | | | content_rating | varchar(10) | NO | | NULL | | | gross | bigint(20) | NO | | NULL | | | imdb_score | float | YES | | 0 | | +----------------+--------------+------+-----+---------+----------------+ 查看表格所有數據 select * from employee; +----+------------+-----------+------------------------+--------+------------+-------+ | id | first_name | last_name | title | salary | hire_date | notes | +----+------------+-----------+------------------------+--------+------------+-------+ | 1 | Robin | Jackman | Software Engineer | 5500 | 2001-10-12 | NULL | | 2 | Taylor | Edward | Software Architect | 7200 | 2002-09-21 | NULL | | 3 | Vivian | Dickens | Database Administrator | 6000 | 2012-08-29 | NULL | | 4 | Harry | Clifford | Database Administrator | 6800 | 2015-12-10 | NULL | | 5 | Eliza | Clifford | Software Engineer | 4750 | 1998-10-19 | NULL | | 6 | Nancy | Newman | Software Engineer | 5100 | 2007-01-23 | NULL | | 7 | Melinda | Clifford | Project Manager | 8500 | 2013-10-29 | NULL | | 8 | Jack | Chan | Test Engineer | 6500 | 2018-09-07 | NULL | | 9 | Harley | Gilbert | Software Architect | 8000 | 2000-07-17 | NULL | +----+------------+-----------+------------------------+--------+------------+-------+ WHERE 語句過濾 select * from employee where last_name=\u0026#34;Clifford\u0026#34;; +----+------------+-----------+------------------------+--------+------------+-------+ | id | first_name | last_name | title | salary | hire_date | notes | +----+------------+-----------+------------------------+--------+------------+-------+ | 4 | Harry | Clifford | Database Administrator | 6800 | 2015-12-10 | NULL | | 5 | Eliza | Clifford | Software Engineer | 4750 | 1998-10-19 | NULL | | 7 | Melinda | Clifford | Project Manager | 8500 | 2013-10-29 | NULL | +----+------------+-----------+------------------------+--------+------------+-------+ WHERE 兩個條件過濾 select * from employee where last_name=\u0026#34;Clifford\u0026#34; and salary=6800; +----+------------+-----------+------------------------+--------+------------+-------+ | id | first_name | last_name | title | salary | hire_date | notes | +----+------------+-----------+------------------------+--------+------------+-------+ | 4 | Harry | Clifford | Database Administrator | 6800 | 2015-12-10 | NULL | +----+------------+-----------+------------------------+--------+------------+-------+ 新增 INSERT INTO yourTABLEname (column1,column2)VALUES(新增項目 1,新增項目 2); 範例:\nINSERT INTO employee (first_name, last_name, title, salary, hire_date) VALUES (\u0026#39;Robin\u0026#39;, \u0026#39;Jackman\u0026#39;, \u0026#39;Software Engineer\u0026#39;, 5500, \u0026#39;2001-10-12\u0026#39;); 更新 update 語句更新數據(先找到要更改資料，再更改比較不會亂掉) !!!注意 update from \u0026ldquo;table 名子\u0026rdquo;; 是對整個 table 進行操作 update employee set salary=10000,(預更改 coulmn = \u0026ldquo;更改值\u0026rdquo;) where title=\u0026quot;Software Architect\u0026rdquo;;\n更新成功\nselect * from employee where title=\u0026#34;Software Architect\u0026#34;; +----+------------+-----------+--------------------+--------+------------+-------+ | id | first_name | last_name | title | salary | hire_date | notes | +----+------------+-----------+--------------------+--------+------------+-------+ | 2 | Taylor | Edward | Software Architect | 10000 | 2002-09-21 | NULL | | 9 | Harley | Gilbert | Software Architect | 10000 | 2000-07-17 | NULL | +----+------------+-----------+--------------------+--------+------------+-------+ 刪除 delete 語句刪除數據 !!!注意 delete from \u0026ldquo;table 名子\u0026rdquo;; 是對整個 table 進行操作\n刪除例句\ndelet from employee where title =\u0026#34;Software Architect\u0026#34;; SQL 字符串相關處理方法 字串拼接 SUBSTRING 字串拼接 CONCAT(\u0026ldquo;A\u0026rdquo;,\u0026ldquo;B\u0026rdquo;)\nselect concat(first_name,\u0026#34;,\u0026#34;,last_name) from employee; +----------------------------------+ | concat(first_name,\u0026#34;,\u0026#34;,last_name) | +----------------------------------+ | Robin,Jackman | | Taylor,Edward | | Vivian,Dickens | | Harry,Clifford | | Eliza,Clifford | | Nancy,Newman | | Melinda,Clifford | | Jack,Chan | | Harley,Gilbert | +----------------------------------+ 字串合併取名為 fullname\nselect concat(first_name,\u0026#34;,\u0026#34;,last_name) as fullname from employee; +------------------+ | fullname | +------------------+ | Robin,Jackman | | Taylor,Edward | | Vivian,Dickens | | Harry,Clifford | | Eliza,Clifford | | Nancy,Newman | | Melinda,Clifford | | Jack,Chan | | Harley,Gilbert | +------------------+ 字串合併 CONCAT_WS CONCAT_WS(\u0026ldquo;這裡輸入拼接字符串\u0026rdquo;, first_name, last_name)\nselect CONCAT_WS(\u0026#34;-\u0026#34;,first_name,last_name) from employee; +-------------------------------------+ | CONCAT_WS(\u0026#34;-\u0026#34;,first_name,last_name) | +-------------------------------------+ | Robin-Jackman | | Taylor-Edward | | Vivian-Dickens | | Harry-Clifford | | Eliza-Clifford | | Nancy-Newman | | Melinda-Clifford | | Jack-Chan | | Harley-Gilbert | +-------------------------------------+ ####　字串 SUBSTRING 字串 SUBSTRING 可簡寫 SUBSTR\n第一個字到第四\nselect SUBSTRING(\u0026#34;Hello Word\u0026#34;,1,4); +-----------------------------+ | SUBSTRING(\u0026#34;Hello Word\u0026#34;,1,4) | +-----------------------------+ | Hell | +-----------------------------+ 從第七個到結束\nselect SUBSTRING(\u0026#34;Hello Word\u0026#34;,7); +---------------------------+ | SUBSTRING(\u0026#34;Hello Word\u0026#34;,7) | +---------------------------+ | Word | +---------------------------+ 從後面數來三個\nselect SUBSTRING(\u0026#34;Hello Word\u0026#34;, -3); +-----------------------------+ | SUBSTRING(\u0026#34;Hello Word\u0026#34;, -3) | +-----------------------------+ | ord | +-----------------------------+ REPLACE,REVERSE and CHAR_LENGTH 字符串取代 REPLACE select REPLACE(\u0026ldquo;一段字串\u0026rdquo;,\u0026ldquo;想改變的字串\u0026rdquo;,\u0026ldquo;改變成甚麼\u0026rdquo;);\n範例:\nselect REPLACE(\u0026#34;Hello World\u0026#34;, \u0026#34;World\u0026#34;, \u0026#34;MySQL\u0026#34;); +------------------------------------------+ | REPLACE(\u0026#34;Hello World\u0026#34;, \u0026#34;World\u0026#34;, \u0026#34;MySQL\u0026#34;) | +------------------------------------------+ | Hello MySQL | +------------------------------------------+ 字符反轉 REVERSE select REVERSE(\u0026ldquo;要反轉字串\u0026rdquo;);\n範例:\nselect REVERSE(\u0026#34;Hello World\u0026#34;); +------------------------+ | REVERSE(\u0026#34;Hello World\u0026#34;) | +------------------------+ | dlroW olleH | +------------------------+ 查看字符串幾個字 CHAR_LENGTH select CHAR_LENGTH(\u0026ldquo;字串\u0026rdquo;);\n範例:\nselect CHAR_LENGTH(\u0026#34;Hello World\u0026#34;); +----------------------------+ | CHAR_LENGTH(\u0026#34;Hello World\u0026#34;) | +----------------------------+ | 11 | +----------------------------+ 大小寫轉換 LOWER AND UPPER 字串變大寫 UPPER\nselect UPPER(\u0026#34;Hello MySQL\u0026#34;); 字串變小寫 LOWER\nselect LOWER(\u0026#34;Hello MySQL\u0026#34;); 大小寫範例:\nselect UPPER(first_name) as first_name, UPPER(last_name) as last_name from employee; +------------+-----------+ | first_name | last_name | +------------+-----------+ | ROBIN | JACKMAN | | TAYLOR | EDWARD | | VIVIAN | DICKENS | | HARRY | CLIFFORD | | ELIZA | CLIFFORD | | NANCY | NEWMAN | | MELINDA | CLIFFORD | | JACK | CHAN | | HARLEY | GILBERT | +------------+-----------+ select 結果的進一步處理 order by 對結果進行排序 將資料庫資料依據某項要求排序 order by(默認升序) + desc(降序)\nselect * from employee order by salary; +----+------------+-----------+------------------------+--------+------------+-------+ | id | first_name | last_name | title | salary | hire_date | notes | +----+------------+-----------+------------------------+--------+------------+-------+ | 5 | Eliza | Clifford | Software Engineer | 4750 | 1998-10-19 | NULL | | 6 | Nancy | Newman | Software Engineer | 5100 | 2007-01-23 | NULL | | 1 | Robin | Jackman | Software Engineer | 5500 | 2001-10-12 | NULL | | 3 | Vivian | Dickens | Database Administrator | 6000 | 2012-08-29 | NULL | | 8 | Jack | Chan | Test Engineer | 6500 | 2018-09-07 | NULL | | 4 | Harry | Clifford | Database Administrator | 6800 | 2015-12-10 | NULL | | 7 | Melinda | Clifford | Project Manager | 8500 | 2013-10-29 | NULL | | 2 | Taylor | Edward | Software Architect | 10000 | 2002-09-21 | NULL | | 9 | Harley | Gilbert | Software Architect | 10000 | 2000-07-17 | NULL | +----+------------+-----------+------------------------+--------+------------+-------+ 選擇第三個 column 進行排序\nselect first_name, last_name , salary from employee order by 3; +------------+-----------+--------+ | first_name | last_name | salary | +------------+-----------+--------+ | Eliza | Clifford | 4750 | | Nancy | Newman | 5100 | | Robin | Jackman | 5500 | | Vivian | Dickens | 6000 | | Jack | Chan | 6500 | | Harry | Clifford | 6800 | | Melinda | Clifford | 8500 | | Taylor | Edward | 10000 | | Harley | Gilbert | 10000 | +------------+-----------+--------+ 先排二在排一\nselect first_name, last_name , salary from employee order by 2,1; +------------+-----------+--------+ | first_name | last_name | salary | +------------+-----------+--------+ | Jack | Chan | 6500 | | Eliza | Clifford | 4750 | | Harry | Clifford | 6800 | | Melinda | Clifford | 8500 | | Vivian | Dickens | 6000 | | Taylor | Edward | 10000 | | Harley | Gilbert | 10000 | | Robin | Jackman | 5500 | | Nancy | Newman | 5100 | +------------+-----------+--------+ LIMIT 限制返回結果進行排序 限制數據返回 + limit 數量\nselect * from employee limit 5; 限制 index 幾到幾\nselect * from employee limit 2,4; 限制 index 多少到最後一個\nselect * from employee limit 2,18446744073709551615; MySQL limit 補充連結\nLIKE 進行字符串搜索過濾 LIKE 模糊字串搜尋 + LIKE \u0026ldquo;字串加%\u0026rdquo; ， %=甚麼都可\nselect * from employee where last_name LIKE \u0026#34;C%\u0026#34;; +----+------------+-----------+------------------------+--------+------------+-------+ | id | first_name | last_name | title | salary | hire_date | notes | +----+------------+-----------+------------------------+--------+------------+-------+ | 4 | Harry | Clifford | Database Administrator | 6800 | 2015-12-10 | NULL | | 5 | Eliza | Clifford | Software Engineer | 4750 | 1998-10-19 | NULL | | 7 | Melinda | Clifford | Project Manager | 8500 | 2013-10-29 | NULL | | 8 | Jack | Chan | Test Engineer | 6500 | 2018-09-07 | NULL | +----+------------+-----------+------------------------+--------+------------+-------+ select * from employee where last_name LIKE \u0026#34;%n\u0026#34;; +----+------------+-----------+-------------------+--------+------------+-------+ | id | first_name | last_name | title | salary | hire_date | notes | +----+------------+-----------+-------------------+--------+------------+-------+ | 1 | Robin | Jackman | Software Engineer | 5500 | 2001-10-12 | NULL | | 6 | Nancy | Newman | Software Engineer | 5100 | 2007-01-23 | NULL | | 8 | Jack | Chan | Test Engineer | 6500 | 2018-09-07 | NULL | +----+------------+-----------+-------------------+--------+------------+-------+ 當知道長度為多少可以變成 + LIKE \u0026ldquo;____\u0026quot;;\nselect * from employee where last_name LIKE \u0026#34;____\u0026#34;; +----+------------+-----------+---------------+--------+------------+-------+ | id | first_name | last_name | title | salary | hire_date | notes | +----+------------+-----------+-------------------+--------+------------+---+ 當要找的字串包含 \u0026ldquo;%\u0026rdquo; , \u0026ldquo;_\u0026ldquo;加上\nselect * from 表格名 where first_name LIKE \u0026ldquo;%%__\u0026quot;;\ncount 對結果進行比較 計算資料表有多少筆資料 COUNT(* 或其他 column)\nselect COUNT(*) from employee; +----------+ | COUNT(*) | +----------+ | 9 | +----------+ distinct 統計唯一値 計算這個 column 有幾種 DISTINCT(不同)\nselect distinct title from employee; +------------------------+ | title | +------------------------+ | Software Engineer | | Software Architect | | Database Administrator | | Project Manager | | Test Engineer | +------------------------+ 利用 CONUT 計算\nselect COUNT(distinct title) from employee; +-----------------------+ | COUNT(distinct title) | +-----------------------+ | 5 | +-----------------------+ GROUP BY 數據整合 select title,count(first_name) from employee group by title; +------------------------+-------------------+ | title | count(first_name) | +------------------------+-------------------+ | Database Administrator | 2 | | Project Manager | 1 | | Software Architect | 2 | | Software Engineer | 3 | | Test Engineer | 1 | +------------------------+-------------------+ MAX 和 MIN 球最大最小值 select max(salary) from employee; +-------------+ | max(salary) | +-------------+ | 10000 | +-------------+ 結合 group by\nselect title, max(salary) from employee group by title; +------------------------+-------------+ | title | max(salary) | +------------------------+-------------+ | Database Administrator | 6800 | | Project Manager | 8500 | | Software Architect | 10000 | | Software Engineer | 5500 | | Test Engineer | 6500 | +------------------------+-------------+ SUM 和 AVG 求和平均值 select sum(salary), avg(salary) from employee; +-------------+-------------------+ | sum(salary) | avg(salary) | +-------------+-------------------+ | 63150 | 7016.666666666667 | +-------------+-------------------+ 使用 max, min, sum, avg 不可這樣寫 select sum(salary), title from employee; 會報錯\nHAVING （✗）select title,count() from employee group by title where title=\u0026quot;Test Engineer; (◯) select title,count() from employee where title=\u0026quot;Test Engineer group by title;\n如果要想在聚合(group by)後過濾，要使用 HAVING\nselect title,count(*) from employee group by title having title=\u0026#34;Test Engineer\u0026#34;; +---------------+----------+ | title | count(*) | +---------------+----------+ | Test Engineer | 1 | +---------------+----------+ DATA TYPE 之數值類型 Numeric Tyoe 1. 整數(絕對值) Integer Types (Exact Value) - INTEGER,INT,SMALLINT,TINYINT,MEDIUMINT,BIGINT 如果要使用到 UNSIGNED 要在新增時加入，莫認為 Signed 範例:\ncreate table test(a TINYINT UNSIGNED , b SMALLINT); 2. 定點數(小數點後位數固定) Fixed-Point Types(Exact Value) - DECIMAL,NUMERIC salary DECIMAL(5,2)第一個參數是總共幾位數，第二個參數是指小數點後有幾位，小數點超過會四捨五入 範例: -999.99 ~ 999.99\n3. 浮點數(無法精確表示) Floating-Point Types(Approximate Value) - FLOAT(4 bytes),DOUBLE(8 bytes) float(range,小數點後位數)，BIT(M),BIT 由 0 和 1 組成,M can range from 1 to 64。\n4. 二進位數位 Bit-Value Type - BIT 範例:\ncreate table test6(a BIT(3)); insert into test6 values(1); insert into test6 values(2); --因為輸出是十進位所以不會顯示 select * from test6; +------+ | a | +------+ | \u0001 | | \u0002 | +------+  --用加0的方式出現 select a+0 from test6; +------+ | a+0 | +------+ | 1 | | 2 | +------+  --這樣子就可以輸出二進制 --bin二進制，oct八進制，hex十六進制。 select bin(a+0) from test6; +----------+ | bin(a+0) | +----------+ | 1 | | 10 | +----------+  Data and Time Type 1. DATE : \u0026ldquo;YYYY-MM-DD\u0026rdquo; 2. TIME : \u0026ldquo;HH:MM:SS\u0026rdquo; \u0026ldquo;12:10\u0026quot;默認為 12 小時 10 分，\u0026ldquo;14\u0026quot;默認為 14 秒，\u0026ldquo;1210\u0026quot;默認為 12 分 10 秒 3.YEAR : 4-digit string number in the range 1901 to 2155 4. DATETIME(8bytes) : \u0026ldquo;YYYY-MM-DD HH:MM:SS\u0026rdquo; 5. TIMESTAMP(4bytes) : range \u0026ldquo;1907-01-01 00:00:01\u0026quot;UTC to \u0026ldquo;2038-01-19 03:14:07\u0026quot;UTC 依照時區改變，會隨著現在時間變化，可用來記錄資料修改時間，可更改 TIMEZONE。 此時間是幾號\nselect DAYOFMONYH(參數) from tablename; 此時間是星期幾\nselect DAYOFWEEK(參數) from tablename; 此時間是此年第幾天\nselect DAYOFYEAR(參數) from tablename; 此時間是幾月\nselect MONTHNAME(b) from demo; 現在日期\nselect CURDATE(); 現在時間\nselect CURTIME(); 現在日期+時間\nselect NOW(); +---------------------+ | NOW() | +---------------------+ | 2020-10-21 15:57:02 | +---------------------+ 資料參考\n小練習:\nselect CONCAT(first_name,\u0026#34; \u0026#34;,last_name,\u0026#34;was hired on\u0026#34;,DATE_FORMAT(hire_date,\u0026#34;%D %M %Y\u0026#34;)) as title from employee; +-----------------------------------------------+ | title | +-----------------------------------------------+ | Robin Jackmanwas hired on12th October 2001 | | Taylor Edwardwas hired on21st September 2002 | | Vivian Dickenswas hired on29th August 2012 | | Harry Cliffordwas hired on10th December 2015 | | Eliza Cliffordwas hired on19th October 1998 | | Nancy Newmanwas hired on23rd January 2007 | | Melinda Cliffordwas hired on29th October 2013 | | Jack Chanwas hired on7th September 2018 | | Harley Gilbertwas hired on17th July 2000 | +-----------------------------------------------+ String Type 1. CHAR and VARCHAR VAR(可變的)\nCHAR length string(0~255) char 的 storage 是固定的，bytes 是固定的\nVARCHAR variable-length strings(0~65535) varchar 的 storage 是可變的，字符也算一個 bytes\n2. BINARY and VARBINARY MySQL 文檔\n3. BLOB and TEXT 通常用來存取大文檔，要排序大文檔通常比較費時，可通過\nset max_sort_length = 2000; 更改 sql 最大文字長度。\nMySQL 文檔\n4. ENUM 選擇的數據類型\n範例:\nCREATE TABLE shirt( size ENUM(\u0026#34;x-small\u0026#34;,\u0026#34;small\u0026#34;,\u0026#34;medium\u0026#34;,\u0026#34;large\u0026#34;,\u0026#34;x-large\u0026#34;) ); 補充連結\n插入時可直接打索引值，速度比 varchar 快。\n5. SET 最多八個 column(2 的 8 次方)\n修改數據類型，使用 ALTER create table user(username VARCHAR(10), password VARCHAR(20)); +----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+-------+ | username | varchar(10) | YES | | NULL | | | password | varchar(20) | YES | | NULL | | +----------+-------------+------+-----+---------+-------+  ALTER table user MODIFY username VARCHAR(15); desc user; +----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+-------+ | username | varchar(15) | YES | | NULL | | | password | varchar(20) | YES | | NULL | | +----------+-------------+------+-----+---------+-------+  成功更改。 SQL 邏輯操作符 Equal 和 NOT Equal 等於不等於 --Equal範例  select * from employee where salary = 8000; --NOT Equal範例  select * from employee where salary != 8000; select * from employee where salary NOT 8000; LIKE 和 NOT LIKE --LIKE範例  --LIKE就是模糊搜尋  select * from employee where first_name like \u0026#34;H%\u0026#34;; --NOT LIKE範例  select * from employee where first_name NOT like \u0026#34;H%\u0026#34;; --嚴格搜尋大小寫BINARY，也可以在創建時加入BINARY  select * from employee where first_name like BINARY \u0026#34;H%\u0026#34;; Greate Than 和 Less Than 大於小於 --\u0026#34; \u0026gt; \u0026#34;可用運算符號替換  select * from employee where salary \u0026gt; 6000; AND 和 OR --AND範例，條件同時符合 select * from employee where salary\u0026gt;6000 and first_name LIKE\u0026#34;H%\u0026#34;; --OR範例，條件其一符合或都符合選項 select * from employee where salary\u0026gt;6000 or first_name LIKE\u0026#34;H%\u0026#34;; BETWEEN 尋找一個 range 之間\n--尋找薪水在6000到8000之間 select * from employee where betweeen 6000 and 8000 IN 和 NOT IN 比較精確地找尋\nselect * from employee where salary in (5000,6000,7000,8000); CASE Statement select *, case when salary \u0026gt;=7000 then \u0026#34;high\u0026#34; else \u0026#34;low\u0026#34; end as tag from employee order by desc; MySQL 內建函數 1. 字符函數 字串拼接:CONCAT()，CONCAT_WS。\n字串大小寫:UPPER()，LOWER()。\n從左右邊數來:LEFT()，RIGHT()。\n字串長度:LENGTH()。\n去除特定字符:LTRIM()，RTRIM()，TRIM()\n字串替換:REPLACE()\n獲取特定字串:SUBSTRING(特定字串,起,尾,)\n2. 數值函數 無條件進位和捨去:CEIL()，FIOOR()\n除數跟餘數:DIV()，MOD()\n平方:POW()\n四捨五入:ROUND()\n3. 日期時間函數 當前時間:NOE()，CURDATE()，CURTIMEE()\n格式化時間:DATE_FORNAT()\n日期增加減少:DASTE_ADD()\n時間差:DATEDIFF(第一個時間,第二個時間)\n4. 訊息函數 獲取當前進程 ID:CONNECTION_ID()\n當前 DATABASE 名稱:DATABASE()\n最後一次生成的 ID:LAST_INSERT_ID()\n當前用戶:USER()\n當前版本:VERSION()\n5. 聚合函數 平均值 AVG()\n計数 COUNT()\n最大值 MAX()\n最小值 MIN()\n求和 SUM()\n6. 加密函數 更改密碼:PASSWORD()\n存取密碼如果資料密要加密時用:MD5()\nRELATIONSHIP 之 ONE TO MANY(一對多) 先新增兩個 table\nCREATE TABLE customers( id INT AUTO_INCREMENT PRIMARY KEY, first_name VARCHAR(100), last_name VARCHAR(100), email VARCHAR(100) ); INSERT INTO customers(first_name, last_name, email) VALUES (\u0026#39;Robin\u0026#39;, \u0026#39;Jackman\u0026#39;, \u0026#39;roj@gmail.com\u0026#39;), (\u0026#39;Taylor\u0026#39;, \u0026#39;Edward\u0026#39;, \u0026#39;taed@gmail.com\u0026#39;), (\u0026#39;Vivian\u0026#39;, \u0026#39;Dickens\u0026#39;, \u0026#39;vidi@gmail.com\u0026#39;), (\u0026#39;Harley\u0026#39;, \u0026#39;Gilbert\u0026#39;, \u0026#39;hgi@gmail.com\u0026#39;); CREATE TABLE orders( id INT AUTO_INCREMENT PRIMARY KEY, order_date DATE, amount DECIMAL(8,2), customer_id INT ); INSERT INTO orders(order_date, amount, customer_id) VALUES (\u0026#39;2001-10-12\u0026#39;, 99.12, 1), (\u0026#39;2001-09-21\u0026#39;, 110.99, 2), (\u0026#39;2001-10-13\u0026#39;, 12.19, 1), (\u0026#39;2001-11-29\u0026#39;, 88.09, 3), (\u0026#39;2001-11-11\u0026#39;, 205.01, 4); 使用 id 連結兩個 table\nselect * from orders where customer_id = (select id from customers where email=\u0026#34;roj@gmail.com\u0026#34;); +----+------------+--------+-------------+ | id | order_date | amount | customer_id | +----+------------+--------+-------------+ | 1 | 2001-10-12 | 99.12 | 1 | | 3 | 2001-10-13 | 12.19 | 1 | +----+------------+--------+-------------+ 使用 Foreign Key 約束關聯 CREATE TABLE customers( id INT AUTO_INCREMENT PRIMARY KEY, first_name VARCHAR(100), last_name VARCHAR(100), email VARCHAR(100) ); INSERT INTO customers(first_name, last_name, email) VALUES (\u0026#39;Robin\u0026#39;, \u0026#39;Jackman\u0026#39;, \u0026#39;roj@gmail.com\u0026#39;), (\u0026#39;Taylor\u0026#39;, \u0026#39;Edward\u0026#39;, \u0026#39;taed@gmail.com\u0026#39;), (\u0026#39;Vivian\u0026#39;, \u0026#39;Dickens\u0026#39;, \u0026#39;vidi@gmail.com\u0026#39;), (\u0026#39;Harley\u0026#39;, \u0026#39;Gilbert\u0026#39;, \u0026#39;hgi@gmail.com\u0026#39;); CREATE TABLE orders( id INT AUTO_INCREMENT PRIMARY KEY, order_date DATE, amount DECIMAL(8,2), customer_id INT, FOREIGN KEY (customer_id) REFERENCES customers(id) ); INSERT INTO orders(order_date, amount, customer_id) VALUES (\u0026#39;2001-10-12\u0026#39;, 99.12, 1), (\u0026#39;2001-09-21\u0026#39;, 110.99, 2), (\u0026#39;2001-10-13\u0026#39;, 12.19, 1), (\u0026#39;2001-11-29\u0026#39;, 88.09, 3), (\u0026#39;2001-11-11\u0026#39;, 205.01, 4); Inner Join 結合兩張 table 取 table 重複部分\nselect * from customers inner join orders where customers.id=orders.customer_id; +----+------------+-----------+----------------+----+------------+--------+-------------+ | id | first_name | last_name | email | id | order_date | amount | customer_id | +----+------------+-----------+----------------+----+------------+--------+-------------+ | 1 | Robin | Jackman | roj@gmail.com | 1 | 2001-10-12 | 99.12 | 1 | | 1 | Robin | Jackman | roj@gmail.com | 3 | 2001-10-13 | 12.19 | 1 | | 2 | Taylor | Edward | taed@gmail.com | 2 | 2001-09-21 | 110.99 | 2 | | 3 | Vivian | Dickens | vidi@gmail.com | 4 | 2001-11-29 | 88.09 | 3 | | 4 | Harley | Gilbert | hgi@gmail.com | 5 | 2001-11-11 | 205.01 | 4 | +----+------------+-----------+----------------+----+------------+--------+-------------+ ieft join 過濾條件式寫在 ON 後面，代表是先針對連結前的指定資料表進行過濾\n過濾條件寫在 WHERE 後面，代表是對連結後取得的資料集合再進行過濾\n--取得自己以及重複部分 select * from customers left join orders on customers.id=orders.customer_id; --如果總和為null換成0 SELECT first_name, last_name, case when SUM(amount) is NULL then 0 else SUM(amount) end as total_amount from customers left join orders on customers.id=orders.customer_id group by customers.id; --第二種null換成0寫法 SELECT first_name, last_name, IFNULL(SUM(amount), 0) from customers left join orders on customers.id=orders.customer_id group by customers.id; rigth join left join 的相反邊\nON DELETE 刪除被 FOREIGN KEY 約束的資料\n--刪除使用者資料，會連帶買的商品一起刪除 --建立資料表同時使用foreign key 和on delete  CREATE TABLE customers( id INT AUTO_INCREMENT PRIMARY KEY, first_name VARCHAR(100), last_name VARCHAR(100), email VARCHAR(100) ); INSERT INTO customers(first_name, last_name, email) VALUES (\u0026#39;Robin\u0026#39;, \u0026#39;Jackman\u0026#39;, \u0026#39;roj@gmail.com\u0026#39;), (\u0026#39;Taylor\u0026#39;, \u0026#39;Edward\u0026#39;, \u0026#39;taed@gmail.com\u0026#39;), (\u0026#39;Vivian\u0026#39;, \u0026#39;Dickens\u0026#39;, \u0026#39;vidi@gmail.com\u0026#39;), (\u0026#39;Harley\u0026#39;, \u0026#39;Gilbert\u0026#39;, \u0026#39;hgi@gmail.com\u0026#39;); CREATE TABLE orders( id INT AUTO_INCREMENT PRIMARY KEY, order_date DATE, amount DECIMAL(8,2), customer_id INT, FOREIGN KEY(customer_id) REFERENCES customers(id) ON DELETE CASCADE ); INSERT INTO orders(order_date, amount, customer_id) VALUES (\u0026#39;2001-10-12\u0026#39;, 99.12, 1), (\u0026#39;2001-09-21\u0026#39;, 110.99, 2), (\u0026#39;2001-10-13\u0026#39;, 12.19, 1), (\u0026#39;2001-11-29\u0026#39;, 88.09, 3), (\u0026#39;2001-11-11\u0026#39;, 205.01, 4); 補充 --兩種方法取小數點後精度  CONVERT(AVG(imdb_score), DECIMAL(2,1)) --ROUND方法去取精度  select ROUND(7.83232); +----------------+ | ROUND(7.83232) | +----------------+ | 8 | +----------------+ 1 row in set (0.00 sec) mysql\u0026gt; select ROUND(7.83232,1); +------------------+ | ROUND(7.83232,1) | +------------------+ | 7.8 | +------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select ROUND(7.57232,1); +------------------+ | ROUND(7.57232,1) | +------------------+ | 7.6 | +------------------+ 1 row in set (0.00 sec) RELATIONSHIP 之 MANY to MANY(多對多) --DATA CREATE TABLE reviewers ( id INT AUTO_INCREMENT PRIMARY KEY, first_name VARCHAR(100), last_name VARCHAR(100) ); CREATE TABLE books( id INT AUTO_INCREMENT PRIMARY KEY, title VARCHAR(100) NOT NULL, released_year YEAR(4) NOT NULL, language VARCHAR(100) NOT NULL, paperback INT NOT NULL ); CREATE TABLE reviews ( id INT AUTO_INCREMENT PRIMARY KEY, rating DECIMAL(2,1), book_id INT, reviewer_id INT, FOREIGN KEY(book_id) REFERENCES books(id), FOREIGN KEY(reviewer_id) REFERENCES reviewers(id) ); INSERT INTO books(title, released_year, language, paperback) VALUES (\u0026#39;Fifty Shades of Grey Series\u0026#39;, 2012, \u0026#39;English\u0026#39;, 514), (\u0026#39;Civilian Publishing Alif Baa Taa: Learning My Arabic Alphabet\u0026#39;, 2018, \u0026#39;Arabic\u0026#39;, 30), (\u0026#39;The Hunger Games (Book 3)\u0026#39;, 2014, \u0026#39;English\u0026#39;, 400), (\u0026#39;Santo Remedio\u0026#39;, 2017, \u0026#39;Spanish\u0026#39;, 240), (\u0026#39;The Fault in Our Stars\u0026#39;, 2012, \u0026#39;English\u0026#39;, 318), (\u0026#39;Harry Potter Und der Stein der Weisen (German Edition)\u0026#39;, 2005, \u0026#39;German\u0026#39;, 334), (\u0026#39;Collection Folio, no. 2\u0026#39;, 1971, \u0026#39;French\u0026#39;, 185), (\u0026#39;Santo remedio: Ilustrado y a color\u0026#39;, 2018, \u0026#39;Spanish\u0026#39;, 216), (\u0026#39;Splatoon 2\u0026#39;, 2017, \u0026#39;Japanese\u0026#39;, 384), (\u0026#39;Minna No Nihongo: Beginner 1, 2nd Edition\u0026#39;, 2012, \u0026#39;Japanese\u0026#39;, 210); INSERT INTO reviewers (first_name, last_name) VALUES (\u0026#39;Thomas\u0026#39;, \u0026#39;Stoneman\u0026#39;), (\u0026#39;Wyatt\u0026#39;, \u0026#39;Skaggs\u0026#39;), (\u0026#39;Kimbra\u0026#39;, \u0026#39;Masters\u0026#39;), (\u0026#39;Domingo\u0026#39;, \u0026#39;Cortes\u0026#39;), (\u0026#39;Colt\u0026#39;, \u0026#39;Steele\u0026#39;), (\u0026#39;Pinkie\u0026#39;, \u0026#39;Petit\u0026#39;), (\u0026#39;Marlon\u0026#39;, \u0026#39;Crafford\u0026#39;); INSERT INTO reviews(book_id, reviewer_id, rating) VALUES (1,1,8.0),(1,2,7.5),(1,3,8.5),(1,4,7.7),(1,5,8.9), (2,1,8.1),(2,4,6.0),(2,3,8.0),(2,6,8.4),(2,5,9.9), (3,1,7.0),(3,6,7.5),(3,4,8.0),(3,3,7.1),(3,5,8.0), (4,1,7.5),(4,3,7.8),(4,4,8.3),(4,2,7.6),(4,5,8.5), (5,1,9.5),(5,3,9.0),(5,4,9.1),(5,2,9.3),(5,5,9.9), (6,2,6.5),(6,3,7.8),(6,4,8.8),(6,2,8.4),(6,5,9.1), (7,2,9.1),(7,5,9.7), (8,4,8.5),(8,2,7.8),(8,6,8.8),(8,5,9.3), (9,2,5.5),(9,3,6.8),(9,4,5.8),(9,6,4.3),(9,5,4.5), (10,5,9.9); 練習題\n找出評論者，評論分數最小,最大,平均,次數，如果次數等於 0 設為 INACTIVE，大於 0 設為 ACTIVE\n--case語句也能用if判斷式 SELECT first_name, last_name, COUNT(rating) as COUNT, MIN(IFNULL(rating, 0)) as MIN, MAX(IFNULL(rating, 0)) as MAX, CONVERT(IFNULL(AVG(rating), 0), DECIMAL(3,2)) AS AVG, IF(COUNT(rating)\u0026gt;0, \u0026#39;ACTIVE\u0026#39;, \u0026#39;INACTIVE\u0026#39;) AS NEW_STATUS, CASE WHEN COUNT(rating)\u0026gt;0 THEN \u0026#39;ACTIVE\u0026#39; ELSE \u0026#34;INACTIVE\u0026#34; END AS STATUS FROM reviewers LEFT JOIN reviews ON reviewers.id=reviews.reviewer_id GROUP BY reviewers.id ORDER BY AVG DESC; ","permalink":"https://joe94113.github.io/blog/mysql/","tags":["SQL"],"title":"MySQL入門筆記"},{"categories":["HTML \u0026 CSS"],"contents":"名片 查看code 個人履歷 未完成 查看code ","permalink":"https://joe94113.github.io/blog/htmlcss-post/","tags":["Frontend"],"title":"HTML CSS作品"},{"categories":["python"],"contents":"line bot : ROBOT小秘書 ID:@627tmjef by 王冠智 (instagram)\n加入好友 功能 1. 普通聊天對話 2. 按 + 傳送位置訊息，跑出附近餐廳 3. YAHOO最新電影 4. KKBOX隨機單曲 5. 抽美女或。。。 6. 聯合報即時新聞 7. DCARD西斯版 ","permalink":"https://joe94113.github.io/blog/linebot-post/","tags":["Bot","Backend"],"title":"Python line bpt"},{"categories":["python"],"contents":"Python雲端自動化動態報表 covid19自動化更新動態報表 爬取github開源的data，每隔一天自動抓取一次資料。 查看報表 貝莉梅youtube經營成效 使用youtube api，每隔六小時自動抓取一次資料。 查看報表 台積電股市新聞報表 利用網頁ajax json檔案，爬取文章編號，只選擇標籤有台積電的新聞。 查看報表 ","permalink":"https://joe94113.github.io/blog/python-post/","tags":["Python"],"title":"Python打造自動化報表"},{"categories":null,"contents":"Imprint Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean semper libero quis dictum dapibus. Nulla egestas vitae augue eu rutrum. Duis ullamcorper dictum ipsum. Interdum et malesuada fames ac ante ipsum primis in faucibus. Suspendisse tortor dui, fermentum non dapibus id, volutpat non odio. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Maecenas fringilla tempus urna ac laoreet. Curabitur sed bibendum lectus. Vivamus gravida venenatis porttitor. Phasellus aliquet nibh vel accumsan malesuada. Nulla nibh enim, auctor nec rhoncus a, pulvinar at tortor. Donec sodales consequat dolor et condimentum. Praesent convallis massa sit amet ultrices porta. Sed commodo, odio et porttitor fringilla, mi tortor sodales nulla, a fermentum dolor mi pulvinar mi.\nNext Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean semper libero quis dictum dapibus. Nulla egestas vitae augue eu rutrum. Duis ullamcorper dictum ipsum. Interdum et malesuada fames ac ante ipsum primis in faucibus. Suspendisse tortor dui, fermentum non dapibus id, volutpat non odio. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Maecenas fringilla tempus urna ac laoreet. Curabitur sed bibendum lectus. Vivamus gravida venenatis porttitor. Phasellus aliquet nibh vel accumsan malesuada. Nulla nibh enim, auctor nec rhoncus a, pulvinar at tortor. Donec sodales consequat dolor et condimentum. Praesent convallis massa sit amet ultrices porta. Sed commodo, odio et porttitor fringilla, mi tortor sodales nulla, a fermentum dolor mi pulvinar mi.\nNext Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean semper libero quis dictum dapibus. Nulla egestas vitae augue eu rutrum. Duis ullamcorper dictum ipsum. Interdum et malesuada fames ac ante ipsum primis in faucibus. Suspendisse tortor dui, fermentum non dapibus id, volutpat non odio. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Maecenas fringilla tempus urna ac laoreet. Curabitur sed bibendum lectus. Vivamus gravida venenatis porttitor. Phasellus aliquet nibh vel accumsan malesuada. Nulla nibh enim, auctor nec rhoncus a, pulvinar at tortor. Donec sodales consequat dolor et condimentum. Praesent convallis massa sit amet ultrices porta. Sed commodo, odio et porttitor fringilla, mi tortor sodales nulla, a fermentum dolor mi pulvinar mi.\n","permalink":"https://joe94113.github.io/static/imprint/","tags":null,"title":"Imprint"}]